<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DeepZoom Viewer</title>
  <style>
    /* CSS Refactor: Grouped logically and used CSS variables for theme */
    :root {
      --bg-color: #2c2c34;
      --overlay-bg: rgba(0, 0, 0, 0.6);
      --accent-color: #4a9eff;
      --text-color: #ffffff;
    }

    html, body { margin: 0; height: 100%; overflow: hidden; background: var(--bg-color); }
    #app { width: 100%; height: 100%; position: relative; }
    canvas { display: block; width: 100%; height: 100%; }

    /* HUD Layer */
    .hud-layer {
      position: absolute; inset: 0; pointer-events: none; z-index: 10;
      display: flex; flex-direction: column; justify-content: space-between; p: 12px;
    }
    .hud-layer > * { pointer-events: auto; }

    .hud-top-left { position: absolute; top: 12px; left: 12px; }
    .hud-bottom-right { position: absolute; bottom: 12px; right: 12px; }

    .label-badge {
      background: var(--overlay-bg); color: var(--text-color);
      padding: 4px 8px; border-radius: 4px; font-family: monospace; font-size: 12px;
    }

    .btn {
      background: var(--overlay-bg); color: var(--text-color); border: none;
      padding: 6px 12px; border-radius: 4px; cursor: pointer; margin-left: 8px;
    }
    .btn:hover { background: rgba(0, 0, 0, 0.8); }

    /* Context Menu */
    .context-bar {
      position: absolute; display: flex; gap: 4px; padding: 6px 8px;
      background: var(--bg-color); border-radius: 8px;
      box-shadow: 0 2px 12px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.1);
      transform: translateX(-50%); z-index: 20; pointer-events: auto;
    }
    /* Vue transition for smooth popup */
    .fade-enter-active, .fade-leave-active { transition: opacity 0.2s, transform 0.2s; }
    .fade-enter-from, .fade-leave-to { opacity: 0; transform: translate(-50%, 10px); }
  </style>
</head>
<body>

  <div id="app">
    <div class="hud-layer">
      <div class="hud-top-left">
        <span class="label-badge">{{ zoomPercentage }}%</span>
        <span class="label-badge" v-if="loadingCount > 0">Loading: {{ loadingCount }}</span>
      </div>
      
      <div class="hud-bottom-right">
        <button class="btn" @click="layoutGrid">Grid (G)</button>
        <button class="btn" @click="fitAll">Fit All (F)</button>
      </div>

      <transition name="fade">
        <div v-if="showContextBar" 
             class="context-bar" 
             :style="{ left: contextBarPos.x + 'px', top: contextBarPos.y + 'px' }">
          <button class="btn" @click="alert('Action!')">Action ({{ selectionCount }})</button>
        </div>
      </transition>
    </div>
  </div>

  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>

  <script>
    const { createApp, ref, computed, onMounted, reactive, shallowRef } = Vue;

    // --- 1. CONFIGURATION & CONSTANTS ---
    const CONFIG = {
      API_BASE: 'http://127.0.0.1:8000',
      COLORS: {
        BG_IMAGE: 0x646496,
        SELECTION: 0x4a9eff,
        BOX_FILL: 0x4a9eff,
      },
      ZOOM: { MIN: 0, MAX: 4, BIAS: 0 },
      TILE_SIZE: 256,
      DBL_CLICK_TIME: 300
    };

    // --- 2. UTILITIES & GEOMETRY ---
    const Geom = {
      // Axis-Aligned Bounding Box intersection
      rectIntersect: (r1, r2) => !(r2.x > r1.x + r1.w || r2.x + r2.w < r1.x || r2.y > r1.y + r1.h || r2.y + r2.h < r1.y),
      
      // Screen (Pixels) -> World (Canvas Units)
      screenToWorld: (sx, sy, stage) => ({
        x: (sx - stage.x) / stage.scale.x,
        y: (sy - stage.y) / stage.scale.y
      }),

      // Normalize a box created by dragging (handle negative width)
      normalizeBox: (x, y, w, h) => ({
        x: w < 0 ? x + w : x,
        y: h < 0 ? y + h : y,
        w: Math.abs(w),
        h: Math.abs(h)
      })
    };

    // --- 3. PIXI VIEW CLASSES ---

    /**
     * Service to fetch and format 16-bit data.
     * Decoupled from the visual component.
     */
    class TileService {
      static async fetchTileTexture(filename, key, level, width, height) {
        const url = `${CONFIG.API_BASE}/tile/${encodeURI(filename)}/${key}`;
        try {
          const res = await fetch(url);
          const buffer = await res.arrayBuffer();
          const uint16 = new Uint16Array(buffer);
          return this._uint16ToTexture(uint16, width, height);
        } catch (e) {
          console.error(`Failed to load tile ${key}`, e);
          return null;
        }
      }

      static _uint16ToTexture(data, w, h) {
        const canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        const ctx = canvas.getContext('2d');
        const imgData = ctx.createImageData(w, h);
        const rgba = imgData.data;

        // Simple normalization (0-4000 -> 0-255)
        // Optimization: Use a lookup table or WebGL shader in production
        for (let i = 0; i < data.length; i++) {
          const val = Math.min(255, (data[i] / 4000) * 255);
          const idx = i * 4;
          rgba[idx] = rgba[idx + 1] = rgba[idx + 2] = val;
          rgba[idx + 3] = 255;
        }
        ctx.putImageData(imgData, 0, 0);
        return PIXI.Texture.from(canvas, { scaleMode: PIXI.SCALE_MODES.NEAREST });
      }
    }

    /**
     * DeepZoomSprite: Handles LOD logic and rendering for a specific image.
     * It does NOT handle input or global state.
     */
    class DeepZoomSprite extends PIXI.Container {
      constructor(metadata, onTextureLoad) {
        super();
        this.metadata = metadata;
        this.onTextureLoad = onTextureLoad; // Callback to request redraw
        
        // State
        this.isSelected = false;
        this.tiles = new Map(); // Cache
        this.fullWidth = metadata.shape[1];
        this.fullHeight = metadata.shape[0];

        // Layers
        this.bg = new PIXI.Graphics();
        this.tileLayer = new PIXI.Container();
        this.overlay = new PIXI.Graphics();
        
        this.tileLayer.sortableChildren = true;
        this.addChild(this.bg, this.tileLayer, this.overlay);
        
        this._drawPlaceholder();
      }

      _drawPlaceholder() {
        this.bg.clear();
        this.bg.beginFill(CONFIG.COLORS.BG_IMAGE, 0.3);
        this.bg.drawRect(0, 0, this.fullWidth, this.fullHeight);
        this.bg.endFill();
      }

      updateSelection(selected) {
        if (this.isSelected === selected) return;
        this.isSelected = selected;
        this.overlay.clear();
        if (selected) {
          // Inverse scale line width so it stays constant on screen
          const lineWidth = 2 / this.parent.scale.x; 
          this.overlay.lineStyle(lineWidth, CONFIG.COLORS.SELECTION, 1);
          this.overlay.drawRect(0, 0, this.fullWidth, this.fullHeight);
          this.zIndex = 1; // Bring selected images to front
        } else {
          this.zIndex = 0;
        }
      }

      /**
       * Main LOD Loop. Called every render frame.
       * @param {PIXI.Rectangle} viewportRect - Visible world area
       * @param {number} worldScale - Current camera zoom
       */
      cullAndLOD(viewportRect, worldScale) {
        // 1. Check if image is visible at all
        const myRect = new PIXI.Rectangle(this.x, this.y, this.fullWidth, this.fullHeight);
        if (!Geom.rectIntersect({ x: viewportRect.x, y: viewportRect.y, w: viewportRect.width, h: viewportRect.height }, 
                                { x: this.x, y: this.y, w: this.fullWidth, h: this.fullHeight })) {
          this.visible = false;
          return;
        }
        this.visible = true;

        // 2. Determine Zoom Level
        // Log2(1/scale) gives us the MIP level. 
        let targetLevel = Math.floor(Math.log2(1 / worldScale)) + CONFIG.ZOOM.BIAS;
        targetLevel = Math.min(Math.max(targetLevel, 0), CONFIG.ZOOM.MAX);

        // 3. Reconcile Tiles
        this.reconcileTiles(targetLevel, viewportRect);
      }

      reconcileTiles(targetLevel, viewportRect) {
        const visibleKeys = new Set();
        
        // Iterate levels from Target (High Detail) -> Max (Low Detail)
        // We draw lower res tiles if high res aren't loaded yet (Painter's algo)
        for (let level = targetLevel; level <= CONFIG.ZOOM.MAX; level++) {
          const size = CONFIG.TILE_SIZE * Math.pow(2, level);
          
          // Calculate grid bounds relative to image origin
          const startX = Math.max(0, viewportRect.x - this.x);
          const startY = Math.max(0, viewportRect.y - this.y);
          const endX = Math.min(this.fullWidth, (viewportRect.x + viewportRect.width) - this.x);
          const endY = Math.min(this.fullHeight, (viewportRect.y + viewportRect.height) - this.y);

          const col0 = Math.floor(startX / size);
          const row0 = Math.floor(startY / size);
          const col1 = Math.floor(endX / size);
          const row1 = Math.floor(endY / size);

          for (let r = row0; r <= row1; r++) {
            for (let c = col0; c <= col1; c++) {
              const key = `L${level}_${r}_${c}`;
              visibleKeys.add(key);

              if (!this.tiles.has(key)) {
                // Only fetch if it's the target level (performance)
                if (level === targetLevel) this._loadTile(key, level, c, r, size);
              } else {
                const tile = this.tiles.get(key);
                if (tile.sprite) {
                  tile.sprite.visible = true;
                  tile.sprite.zIndex = CONFIG.ZOOM.MAX - level; // High res on top
                }
              }
            }
          }
        }

        // Hide non-visible tiles
        for (const [key, tile] of this.tiles) {
          if (!visibleKeys.has(key) && tile.sprite) {
            tile.sprite.visible = false;
          }
        }
      }

      async _loadTile(key, level, col, row, size) {
        // Placeholder entry to prevent double-fetching
        this.tiles.set(key, { loading: true, sprite: null });

        // Calculate actual dimensions (edge tiles might be smaller)
        const x = col * size;
        const y = row * size;
        const w = Math.min(size, this.fullWidth - x) / Math.pow(2, level);
        const h = Math.min(size, this.fullHeight - y) / Math.pow(2, level);

        const texture = await TileService.fetchTileTexture(this.metadata.filename, `L${level}_Z0_${row}_${col}`, level, w, h);

        if (texture) {
          const sprite = new PIXI.Sprite(texture);
          sprite.x = x; 
          sprite.y = y;
          sprite.scale.set(Math.pow(2, level)); // Scale up low-res tiles to cover area
          this.tileLayer.addChild(sprite);
          
          this.tiles.set(key, { loading: false, sprite });
          this.onTextureLoad(); // Trigger render
        } else {
          this.tiles.delete(key); // Retry later
        }
      }
    }

    // --- 4. INPUT MANAGEMENT ---

    /**
     * Handles all Mouse/Keyboard events. 
     * Manipulates the Stage and Selection state.
     */
    class InputManager {
      constructor(domElement, stage, state, onRequestRender) {
        this.dom = domElement;
        this.stage = stage;
        this.state = state;
        this.requestRender = onRequestRender;

        // Internal Input State
        this.isPanning = false;
        this.isDraggingItems = false;
        this.isSelectingBox = false;
        this.lastPos = { x: 0, y: 0 };
        this.dragStart = { x: 0, y: 0 };
        this.boxStart = { x: 0, y: 0 };

        this._bindEvents();
      }

      _bindEvents() {
        this.dom.addEventListener('mousedown', this._onDown.bind(this));
        window.addEventListener('mousemove', this._onMove.bind(this));
        window.addEventListener('mouseup', this._onUp.bind(this));
        this.dom.addEventListener('wheel', this._onWheel.bind(this), { passive: false });
        window.addEventListener('keydown', this._onKey.bind(this));
      }

      _onDown(e) {
        e.preventDefault();
        const worldPos = Geom.screenToWorld(e.clientX, e.clientY, this.stage);
        this.lastPos = { x: e.clientX, y: e.clientY };

        // 1. Middle Mouse / Alt: PAN
        if (e.button === 1 || e.altKey) {
          this.isPanning = true;
          this.dom.style.cursor = 'grabbing';
          return;
        }

        // 2. Left Mouse: SELECT or DRAG
        // Hit Test (Reverse order for top-most check)
        const hitImage = this.state.images.slice().reverse().find(img => 
          Geom.rectIntersect({x: worldPos.x, y: worldPos.y, w:0, h:0}, {x: img.x, y: img.y, w: img.fullWidth, h: img.fullHeight})
        );

        if (hitImage) {
          const isMulti = e.metaKey || e.ctrlKey;
          
          if (!this.state.selection.has(hitImage) && !isMulti) {
            this.state.selection.clear();
          }
          
          if (isMulti && this.state.selection.has(hitImage)) {
            this.state.selection.delete(hitImage);
          } else {
            this.state.selection.add(hitImage);
            this.isDraggingItems = true;
          }
        } else {
          // Clicked Void
          if (!e.metaKey && !e.ctrlKey) this.state.selection.clear();
          this.isSelectingBox = true;
          this.boxStart = { x: e.clientX, y: e.clientY };
          this.state.selectionBox = { active: true, x: 0, y: 0, w: 0, h: 0 };
        }
        
        this.requestRender();
      }

      _onMove(e) {
        if (this.isPanning) {
          const dx = e.clientX - this.lastPos.x;
          const dy = e.clientY - this.lastPos.y;
          this.stage.x += dx;
          this.stage.y += dy;
          this.lastPos = { x: e.clientX, y: e.clientY };
          this.requestRender();
        } 
        else if (this.isDraggingItems) {
          const dx = (e.clientX - this.lastPos.x) / this.stage.scale.x;
          const dy = (e.clientY - this.lastPos.y) / this.stage.scale.y;
          this.state.selection.forEach(img => {
            img.x += dx;
            img.y += dy;
          });
          this.lastPos = { x: e.clientX, y: e.clientY };
          this.requestRender();
        }
        else if (this.isSelectingBox) {
          // Update Box Geometry
          const rect = Geom.normalizeBox(
            this.boxStart.x, this.boxStart.y, 
            e.clientX - this.boxStart.x, e.clientY - this.boxStart.y
          );
          // Convert to World for storage (optional, or store screen)
          // Here we store Screen Coords for the box UI
          this.state.selectionBox = { active: true, ...rect };
          this.requestRender();
        }
      }

      _onUp(e) {
        this.isPanning = false;
        this.isDraggingItems = false;
        this.dom.style.cursor = 'default';

        if (this.isSelectingBox) {
          // Commit Box Selection
          const sb = this.state.selectionBox;
          const p1 = Geom.screenToWorld(sb.x, sb.y, this.stage);
          const p2 = Geom.screenToWorld(sb.x + sb.w, sb.y + sb.h, this.stage);
          const worldBox = { x: p1.x, y: p1.y, w: p2.x - p1.x, h: p2.y - p1.y };

          this.state.images.forEach(img => {
            if (Geom.rectIntersect(worldBox, { x: img.x, y: img.y, w: img.fullWidth, h: img.fullHeight })) {
              this.state.selection.add(img);
            }
          });

          this.isSelectingBox = false;
          this.state.selectionBox.active = false;
          this.requestRender();
        }
      }

      _onWheel(e) {
        e.preventDefault();
        
        // Pinch-to-zoom (trackpad) or Ctrl+wheel (mouse): ZOOM
        if (e.ctrlKey) {
          const zoomIntensity = 0.01;
          const oldScale = this.stage.scale.x;
          const newScale = oldScale * (1 - e.deltaY * zoomIntensity);
          
          // Clamp
          if (newScale < 0.01 || newScale > 50) return;

          // Zoom toward mouse point
          const mouseX = e.clientX;
          const mouseY = e.clientY;
          const worldPos = Geom.screenToWorld(mouseX, mouseY, this.stage);
          
          // Apply Scale
          this.stage.scale.set(newScale);

          // Adjust Position to keep worldPos under mouse
          this.stage.x = mouseX - worldPos.x * newScale;
          this.stage.y = mouseY - worldPos.y * newScale;
        } else {
          // Regular scroll/swipe: PAN
          this.stage.x -= e.deltaX;
          this.stage.y -= e.deltaY;
        }

        this.requestRender();
      }

      _onKey(e) {
        // Dispatch custom events for Vue to pick up if needed, or handle directly
        if (e.code === 'KeyF') document.dispatchEvent(new CustomEvent('action-fit'));
        if (e.code === 'KeyG') document.dispatchEvent(new CustomEvent('action-grid'));
      }
    }

    // --- 5. VUE APP ROOT ---
    createApp({
      setup() {
        // -- Reactive Data (UI Only) --
        const zoomPercentage = ref(100);
        const loadingCount = ref(0); // TODO: Hook up to TileService
        const selectionCount = ref(0);
        const showContextBar = ref(false);
        const contextBarPos = reactive({ x: 0, y: 0 });

        // -- Non-Reactive Data (High Performance) --
        // We avoid Vue proxies for the heavy PIXI objects to prevent memory leaks and lag
        const state = {
          app: null,
          worldContainer: null,
          images: [], // Array of DeepZoomSprite
          selection: new Set(),
          selectionBox: { active: false, x:0, y:0, w:0, h:0 }
        };

        const boxGraphics = new PIXI.Graphics();
        let renderRequested = false;

        // -- Rendering --
        const requestRender = () => {
          if (!renderRequested) {
            renderRequested = true;
            requestAnimationFrame(renderLoop);
          }
        };

        const renderLoop = () => {
          renderRequested = false;
          if (!state.app) return;

          // 1. Sync Selection Visuals
          state.images.forEach(img => img.updateSelection(state.selection.has(img)));

          // 2. Draw Selection Box
          boxGraphics.clear();
          if (state.selectionBox.active) {
            const { x, y, w, h } = state.selectionBox;
            boxGraphics.beginFill(CONFIG.COLORS.BOX_FILL, 0.2);
            boxGraphics.lineStyle(1, CONFIG.COLORS.BOX_FILL, 0.8);
            boxGraphics.drawRect(x, y, w, h);
            boxGraphics.endFill();
          }

          // 3. Compute LOD for Viewport
          // This is the "Culling" phase
          const viewport = {
            x: -state.worldContainer.x / state.worldContainer.scale.x,
            y: -state.worldContainer.y / state.worldContainer.scale.y,
            width: state.app.screen.width / state.worldContainer.scale.x,
            height: state.app.screen.height / state.worldContainer.scale.y
          };
          
          state.images.forEach(img => img.cullAndLOD(viewport, state.worldContainer.scale.x));

          // 4. Render
          state.app.renderer.render(state.app.stage);

          // 5. Update UI State (Vue)
          updateUI();
        };

        const updateUI = () => {
          zoomPercentage.value = Math.round(state.worldContainer.scale.x * 100);
          selectionCount.value = state.selection.size;
          
          if (state.selection.size > 0) {
            showContextBar.value = true;
            // Calculate center of selection in Screen Space
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.selection.forEach(img => {
              const tl = { x: img.x, y: img.y };
              const br = { x: img.x + img.fullWidth, y: img.y + img.fullHeight };
              minX = Math.min(minX, tl.x); minY = Math.min(minY, tl.y);
              maxX = Math.max(maxX, br.x); maxY = Math.max(maxY, br.y);
            });
            
            const screenTopLeft = {
              x: minX * state.worldContainer.scale.x + state.worldContainer.x,
              y: minY * state.worldContainer.scale.y + state.worldContainer.y
            };
            const w = (maxX - minX) * state.worldContainer.scale.x;
            
            contextBarPos.x = screenTopLeft.x + (w / 2);
            contextBarPos.y = Math.max(10, screenTopLeft.y - 50);
          } else {
            showContextBar.value = false;
          }
        };

        // -- Actions --
        const addImage = async (filename) => {
          try {
            const res = await fetch(`${CONFIG.API_BASE}/file/${filename}`);
            const meta = await res.json();
            const img = new DeepZoomSprite({ filename, ...meta }, requestRender);
            
            state.images.push(img);
            state.worldContainer.addChild(img);
            requestRender();
          } catch(e) { console.error("Load failed", e); }
        };

        const fitAll = () => {
          if (state.images.length === 0) return;
          // Simple bounds calculation
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          state.images.forEach(img => {
            minX = Math.min(minX, img.x);
            maxX = Math.max(maxX, img.x + img.fullWidth);
            minY = Math.min(minY, img.y);
            maxY = Math.max(maxY, img.y + img.fullHeight);
          });

          const w = maxX - minX;
          const h = maxY - minY;
          const pad = 50;

          const scale = Math.min(
            (state.app.screen.width - pad*2) / w,
            (state.app.screen.height - pad*2) / h
          );

          state.worldContainer.scale.set(scale);
          state.worldContainer.x = (state.app.screen.width - w * scale) / 2 - minX * scale;
          state.worldContainer.y = (state.app.screen.height - h * scale) / 2 - minY * scale;
          requestRender();
        };

        const layoutGrid = () => {
          const cols = Math.ceil(Math.sqrt(state.images.length));
          const pad = 50;
          let cx = 0, cy = 0, maxH = 0;
          
          state.images.forEach((img, i) => {
            if (i > 0 && i % cols === 0) {
              cx = 0; 
              cy += maxH + pad;
              maxH = 0;
            }
            img.x = cx;
            img.y = cy;
            cx += img.fullWidth + pad;
            maxH = Math.max(maxH, img.fullHeight);
          });
          fitAll();
        };

        // -- Lifecycle --
        onMounted(() => {
          const canvasContainer = document.getElementById('app');
          
          // Init Pixi
          state.app = new PIXI.Application({
            resizeTo: canvasContainer,
            backgroundColor: 0x000000,
            antialias: true,
            autoStart: false // Essential for our manual render loop
          });
          canvasContainer.appendChild(state.app.view);

          // Scene Setup
          state.worldContainer = new PIXI.Container();
          state.worldContainer.sortableChildren = true;
          state.app.stage.addChild(state.worldContainer);
          state.app.stage.addChild(boxGraphics); // UI on top

          // Init Input Manager
          new InputManager(state.app.view, state.worldContainer, state, requestRender);

          // Event Listeners for Buttons
          document.addEventListener('action-fit', fitAll);
          document.addEventListener('action-grid', layoutGrid);

          // Load Dummy Data
          const files = ['002_IDv3__aa855_s05_c0.tif', '002_IDv3__aa855_s05_c1.tif', 
                         '002_IDv3__aa855_s05_c2.tif', '002_IDv3__aa855_s05_c3.tif'];
          files.forEach(addImage);

          // Layout delay (dirty hack, ideally wait for metadata promises)
          setTimeout(layoutGrid, 1000);
        });

        return {
          zoomPercentage, loadingCount, selectionCount,
          showContextBar, contextBarPos,
          fitAll, layoutGrid
        };
      }
    }).mount('#app');
  </script>
</body>
</html>