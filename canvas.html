<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DeepZoom</title>
  <style>
    /* --- CSS Styles (Unchanged) --- */
    html, body { margin: 0; height: 100%; overflow: hidden; background: #2c2c34; color: white; font-family: sans-serif;}
    #app { width: 100%; height: 100%; touch-action: none; position: relative; }
    canvas { display: block; width: 100%; height: 100%; }
    viewport-hud { position: absolute; inset: 0; pointer-events: none; display: block; z-index: 10; }
    viewport-hud > * { pointer-events: auto; }
    .hud-top-left { position: absolute; top: 12px; left: 12px; }
    .hud-bottom-right { position: absolute; bottom: 12px; right: 12px; }
    .hud-label { background: rgba(0,0,0,0.6); color: #fff; padding: 4px 8px; border-radius: 4px; font-family: monospace; font-size: 12px; }
    .hud-btn { background: rgba(0,0,0,0.6); color: #fff; border: none; padding: 6px 12px; border-radius: 4px; font-family: sans-serif; font-size: 12px; cursor: pointer; margin-left: 1ch; }
    .hud-btn:hover { background: rgba(0,0,0,0.8); }
    .context-popup-bar { position: absolute; display: flex; flex-direction: row; align-items: center; gap: 8px; padding: 12px; background: #2c2c34; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.1); pointer-events: auto; transform: translateX(-50%); z-index: 20; }
    .context-popup-bar.hidden { display: none; }
    .context-popup-bar button { background: transparent; border: none; color: #fff; padding: 6px 12px; border-radius: 4px; font-family: sans-serif; font-size: 13px; cursor: pointer; white-space: nowrap; }
    .context-popup-bar button:hover { background: rgba(255,255,255,0.1); }
    .hud-controls { position: absolute; bottom: 12px; left: 12px; background: rgba(0,0,0,0.6); border-radius: 4px; padding: 12px; display: flex; flex-direction: column; gap: 8px; font-family: sans-serif; font-size: 12px; color: #fff; }
    .control-row { display: flex; align-items: center; gap: 8px; }
    .control-row label { min-width: 60px; }
    .control-row input[type="range"] { width: 100px; }
    .control-row input[type="number"] { width: 60px; padding: 4px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 2px; }
    .control-row select { padding: 4px 8px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 2px; }
  </style>
</head>
<body>
  <div id="app">
    <viewport-hud>
      <div class="hud-top-left">
        <span id="zoom-label" class="hud-label">{{ (camera.scale * 100).toFixed(0) }}%</span>
      </div>
      <div class="hud-bottom-right">
        <button id="grid-btn" class="hud-btn" @click="layoutGrid">Grid (G)</button>
        <button id="fit-btn" class="hud-btn" @click="fitAll">Fit All (F)</button>
      </div>

      <!-- Context Popup bar -->
      <div id="context-popup-bar" class="context-popup-bar hidden">
        <div class="control-row">
          <label>Opacity:</label>
          <input v-model="settings.opacity" type="range" id="opacity-slider" min="0" max="1" step="0.02" value="1" @input="updateSelection()">
          <span id="opacity-value">{{ settings.opacity }}</span>
        </div>
        <div class="control-row">
          <label>Min:</label>
          <input v-model="settings.min" type="number" id="min-input" min="0" max="65535" value="0" @change="updateSelection()">
          <span>{{ settings.min }}</span>
        </div>
        <div class="control-row">
          <label>Max:</label>
          <input v-model="settings.max" type="range" id="max-input" min="0" max="65535" value="4000" @input="updateSelection()">
        </div>
        <div class="control-row">
          <!-- <label>Colormap:</label> -->
          <select v-model="settings.colormap" id="colormap-select" @change="updateSelection()">
            <option value="red">ðŸ”´ Red</option>
            <option value="green">ðŸŸ¢ Green</option>
            <option value="blue">ðŸ”µ Blue</option>
            <option value="cyan">ðŸ©µ Cyan</option>
            <option value="magenta">ðŸ©· Magenta</option>
            <option value="yellow">ðŸ’› Yellow</option>
            <option value="viridis">ðŸŒ¿ Viridis</option>
            <option value="inferno">ðŸ”¥ Inferno</option>
            <option value="turbo">ðŸŒˆ Turbo</option>
            <option value="gray">âšª Grayscale</option>
          </select>
        </div>
      </div>
    </viewport-hud>
  </div>

  <script src="/assets/js/vue.min.js"></script>
  <script src="/assets/js/pixi.min.js"></script>

  <script>
    const { createApp, onMounted, ref, reactive, computed, watch, toRefs } = Vue;

    // ==========================================
    // MODULE 1: Constants & Utilities
    // ==========================================
    const Config = {
      BASE_URL: 'http://127.0.0.1:8000',
      TILE_SIZE: 256,
      MAX_ZOOM: 4,
      LOD_BIAS: 2,
      COLORS: {
        BG: 0x646496,
        SELECTION: 0x4a9eff
      }
    };

    const colormapCache = new Map();

    const Utils = {
      /** Axis-Aligned Bounding Box intersection */
      rectsIntersect(r1, r2) {
        return !(r2.x > r1.x + r1.w || 
                 r2.x + r2.w < r1.x || 
                 r2.y > r1.y + r1.h || 
                 r2.y + r2.h < r1.y);
      },

      /** Screen pixel -> World coordinate conversion */
      screenToWorld(screenX, screenY, cameraState) {
        return {
          x: (screenX - cameraState.offsetX) / cameraState.scale,
          y: (screenY - cameraState.offsetY) / cameraState.scale
        };
      },
      
      /**
       * 16-bit array to Texture conversion.
       */
      uint16ToTexture(uint16Data, width, height) {
        // Convert Uint16 (0-65535) to Float32 (0.0-1.0)
        const float32Data = new Float32Array(uint16Data.length);
        for (let i = 0; i < uint16Data.length; i++) {
          float32Data[i] = uint16Data[i] / 65535;
        }

        // Create a Pixi Buffer Resource
        const resource = new PIXI.BufferResource(float32Data, {
          width: width,
          height: height,
        });

        // Create BaseTexture using Float format
        // FORMATS.RED ensures we treat it as single channel
        const baseTex = new PIXI.BaseTexture(resource, {
          format: PIXI.FORMATS.RED, 
          type: PIXI.TYPES.FLOAT,
          scaleMode: PIXI.SCALE_MODES.LINEAR // NEAREST for pixel perfect
        });

        return new PIXI.Texture(baseTex);
      },

      /**
       *  Factory for creating the colormaps once
       */
      createColormapTexture: (name) => {
        if (colormapCache.has(name)) return colormapCache.get(name)

        const canvas = document.createElement('canvas');
        canvas.width = 256;
        canvas.height = 1;
        const ctx = canvas.getContext('2d');
        
        const grad = ctx.createLinearGradient(0, 0, 256, 0);

        // We use approximate stops for the complex scientific colormaps
        switch (name) {
          // --- Perceptually Uniform Sequential ---
          case 'viridis':
            grad.addColorStop(0.0, '#440154');
            grad.addColorStop(0.25, '#3b528b');
            grad.addColorStop(0.5, '#21918c');
            grad.addColorStop(0.75, '#5ec962');
            grad.addColorStop(1.0, '#fde725');
            break;

          case 'inferno':
            grad.addColorStop(0.0, '#000004');
            grad.addColorStop(0.25, '#420a68');
            grad.addColorStop(0.5, '#932667');
            grad.addColorStop(0.75, '#dd513a');
            grad.addColorStop(1.0, '#fca50a');
            break;

          case 'turbo':
            // Turbo is complex; these stops approximate the rainbow-ish arc
            grad.addColorStop(0.0, '#30123b');
            grad.addColorStop(0.2, '#28bceb'); // Light Blue
            grad.addColorStop(0.4, '#a4fc3c'); // Greenish
            grad.addColorStop(0.6, '#fb8022'); // Orange
            grad.addColorStop(0.8, '#c42803'); // Red
            grad.addColorStop(1.0, '#7a0403'); // Deep Red
            break;

          // --- Simple Linear (Black -> Color) ---
          case 'gray':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#ffffff');
            break;
          case 'red':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#ff0000');
            break;
          case 'green':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#00ff00');
            break;
          case 'blue':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#0000ff');
            break;
          case 'cyan':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#00ffff');
            break;
          case 'magenta':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#ff00ff');
            break;
          case 'yellow':
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#ffff00');
            break;

          default:
            console.warn(`Colormap '${name}' not found, defaulting to grayscale.`);
            grad.addColorStop(0, '#000000');
            grad.addColorStop(1, '#ffffff');
        }
        
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 256, 1);
        
        const tex = PIXI.Texture.from(canvas);
        
        // LUT settings
        tex.baseTexture.wrapMode = PIXI.WRAP_MODES.CLAMP;
        // Ensure smooth gradients when sampling between pixels
        tex.baseTexture.scaleMode = PIXI.SCALE_MODES.LINEAR; 

        // 4. Save to Cache
        colormapCache.set(name, tex);

        return tex;
      },
    };

    const TileShader = {
      // Standard Pixi vertex shader
      vert: `
        precision mediump float;
        attribute vec2 aVertexPosition;
        attribute vec2 aTextureCoord;
        uniform mat3 projectionMatrix;
        uniform mat3 translationMatrix;
        uniform mat3 uTransformMatrix;
        varying vec2 vTextureCoord;
        
        void main(void) {
            gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
            vTextureCoord = aTextureCoord;
        }`,

      // Custom microscopy logic
      frag: `
        precision mediump float;
        varying vec2 vTextureCoord;
        
        uniform sampler2D uSampler;     // The raw image tile
        uniform sampler2D uColormap;    // The color gradient (LUT)
        
        uniform float uMin;             // Black point (0.0 to 1.0)
        uniform float uMax;             // White point (0.0 to 1.0)
        uniform float uGamma;           // Gamma correction
        uniform float uOpacity;         // Global opacity
        
        void main(void) {
            // 1. Sample raw intensity (assumes texture is Red channel or Luminance)
            float intensity = texture2D(uSampler, vTextureCoord).r;
            
            // 2. Normalize (Contrast Stretching)
            float range = max(uMax - uMin, 0.00001);
            float normalized = clamp((intensity - uMin) / range, 0.0, 1.0);
            
            // 3. Apply Gamma
            // Power function: pixel = pixel ^ (1 / gamma)
            normalized = pow(normalized, 1.0 / uGamma);
            
            // 4. Color Mapping
            vec4 color = texture2D(uColormap, vec2(normalized, 0.5));
            
            // 5. Calculate the final alpha
            float alpha = color.a * uOpacity;
            
            // Premultiply the RGB channels by the alpha
            // This ensures that when alpha is 0, RGB is also 0
            gl_FragColor = vec4(color.rgb * alpha, alpha);
        }`
    }

    // ==========================================
    // MODULE 2: Core Domain Logic
    // ==========================================

    /**
     * DeepZoomImage (Refactored DraggableImage)
     * Encapsulates the Pixi display logic and the Tile LOD mathematics.
     */
    class DeepZoomImage {
      constructor(x, y, metadata, onRequestRender) {
        // Data Model
        this.x = x;
        this.y = y;
        this.width = metadata.shape[1]; // shape is usually [y, x]
        this.height = metadata.shape[0];
        this.scale = 1;
        this.selected = false;
        this.metadata = metadata;

        // Display Settings
        this.min = 0.0
        this.max = 4000.0
        this.gamma = 1.0
        this.opacity = 0.77
        this.colormap = 'gray'
        this.blending = 'translucent'

        // Shader State
        this.uniforms = {
          uMin: this.min / 65535,
          uMax: this.max / 65535,
          uGamma: this.gamma,
          uOpacity: this.opacity,
          uColormap: Utils.createColormapTexture(this.colormap), 
          uSampler: PIXI.Texture.WHITE // Placeholder
        };

        // Dependencies
        this.onRequestRender = onRequestRender;

        // State
        this.tiles = new Map(); // Cache
        
        // Visuals (Pixi)
        this.container = new PIXI.Container();
        this.geometry = new PIXI.Geometry()
          .addAttribute('aVertexPosition', [0, 0, 1, 0, 1, 1, 0, 1], 2)
          .addAttribute('aTextureCoord', [0, 0, 1, 0, 1, 1, 0, 1], 2)
          .addIndex([0, 1, 2, 0, 2, 3]);

        this.program = PIXI.Program.from(TileShader.vert, TileShader.frag)

        this._initVisuals();
      }

      _initVisuals() {
        this.tileContainer = new PIXI.Container();
        this.tileContainer.sortableChildren = true; // Essential for LOD stacking
        this.overlayGraphics = new PIXI.Graphics();
        
        this.textLabel = new PIXI.Text('', {
          fontFamily: 'monospace', fontSize: 14, fill: 0xaaaaaa,
        });
        this.overlayGraphics.addChild(this.textLabel);

        this.container.addChild(
          this.tileContainer,
          this.overlayGraphics,
        );
      }

      /** Checks if point is inside this image (World Coords) */
      hitTest(wx, wy) {
        return wx >= this.x && wx <= this.x + this.width * this.scale &&
               wy >= this.y && wy <= this.y + this.height * this.scale;
      }

      /**
       * Core LOD Logic (The "Painter's Algorithm").
       * Preserved from original code.
       */
      computeVisibleTiles(appScreen, cameraState) {
        const worldScale = cameraState.scale * this.scale;
        
        // 1. Calculate Target LOD
        let targetLevel = Math.floor(Math.log2(1 / worldScale)) + Config.LOD_BIAS;
        targetLevel = Math.min(Math.max(targetLevel, 0), Config.MAX_ZOOM);

        // 2. Viewport Culling
        const viewportX = -cameraState.offsetX / cameraState.scale;
        const viewportY = -cameraState.offsetY / cameraState.scale;
        const viewportW = appScreen.width / cameraState.scale;
        const viewportH = appScreen.height / cameraState.scale;

        // Convert Viewport to Local Image Space
        const ix0 = (viewportX - this.x) / this.scale;
        const iy0 = (viewportY - this.y) / this.scale;
        const ix1 = (viewportX + viewportW - this.x) / this.scale;
        const iy1 = (viewportY + viewportH - this.y) / this.scale;

        const cx0 = Math.max(0, ix0);
        const cy0 = Math.max(0, iy0);
        const cx1 = Math.min(this.width, ix1);
        const cy1 = Math.min(this.height, iy1);

        const newVisibleKeys = new Set();

        // 3. Recursive Visibility Loop (High Res -> Low Res)
        for (let level = targetLevel; level <= Config.MAX_ZOOM; level++) {
          const effectiveTileSize = Config.TILE_SIZE * Math.pow(2, level);
          const tx0 = Math.floor(cx0 / effectiveTileSize);
          const ty0 = Math.floor(cy0 / effectiveTileSize);
          const tx1 = Math.floor(cx1 / effectiveTileSize);
          const ty1 = Math.floor(cy1 / effectiveTileSize);

          for (let ty = ty0; ty <= ty1; ty++) {
            for (let tx = tx0; tx <= tx1; tx++) {
              const tileX0 = tx * effectiveTileSize;
              const tileY0 = ty * effectiveTileSize;
              
              const tileWidth = Math.round(Math.min(effectiveTileSize, this.width - tileX0) / Math.pow(2, level));
              const tileHeight = Math.round(Math.min(effectiveTileSize, this.height - tileY0) / Math.pow(2, level));

              if (tileWidth <= 0 || tileHeight <= 0) continue;

              const tileData = { tz: 0, ty, tx, level, effectiveTileSize, tileWidth, tileHeight };
              const key = `L${level}_Z0_${ty}_${tx}`;
              
              newVisibleKeys.add(key);

              // Only fetch if it's the target level
              const shouldFetch = (level === targetLevel);
              this._syncTileSprite(tileData, key, shouldFetch);
            }
          }
        }

        // 4. Cleanup invisible meshes
        for (const [key, data] of this.tiles.entries()) {
          if (!newVisibleKeys.has(key) && data.mesh) {
            data.mesh.visible = false;
          }
        }
      }

      _syncTileSprite(tile, key, shouldFetch) {
        let cached = this.tiles.get(key);

        if (!cached) {
          if (shouldFetch) {
            this.tiles.set(key, { loading: true, mesh: null, texture: null, level: tile.level });
            this._fetchTile(tile, key);
          }
          return;
        }

        // Lazy Mesh Creation
        if (cached.texture && !cached.mesh) {
          // 1. Create specific shader for this tile
          // We clone uniforms so we can set the specific uSampler for this tile
          const tileUniforms = { ...this.uniforms, uSampler: cached.texture };
          
          const shader = new PIXI.Shader(this.program, tileUniforms);
          
          // 2. Create Mesh
          const mesh = new PIXI.Mesh(this.geometry, shader);
          
          // 3. Store reference
          this.tileContainer.addChild(mesh);
          cached.mesh = mesh; 
        }

        // Update Mesh Transform
        if (cached.mesh) {
          cached.mesh.visible = true;
          cached.mesh.x = tile.tx * tile.effectiveTileSize;
          cached.mesh.y = tile.ty * tile.effectiveTileSize;
          
          const scaleFactor = Math.pow(2, tile.level);
          cached.mesh.scale.set(tile.tileWidth * scaleFactor, tile.tileHeight * scaleFactor);
          cached.mesh.zIndex = Config.MAX_ZOOM - tile.level;
          
          // IMPORTANT: Keep uniforms in sync if they changed globally
          // The uSampler must remain the specific texture for this tile, 
          // but settings like uMin/uMax must mirror the global state.
          cached.mesh.shader.uniforms.uMin = this.uniforms.uMin;
          cached.mesh.shader.uniforms.uMax = this.uniforms.uMax;
          cached.mesh.shader.uniforms.uGamma = this.uniforms.uGamma;
          cached.mesh.shader.uniforms.uOpacity = this.uniforms.uOpacity;
          cached.mesh.shader.uniforms.uColormap = this.uniforms.uColormap;
        }
      }

      _fetchTile(tile, key) {
        // [OPTIMIZATION]: A dedicated request queue/manager would prevent 
        // spamming the server if the user pans quickly.
        fetch(`${Config.BASE_URL}/tile/${encodeURI(this.metadata.filename)}/${key}`)
          .then(res => res.arrayBuffer())
          .then(buffer => {
            // Check if still in cache (might have been culled)
            const cached = this.tiles.get(key);
            if (!cached) return;

            const uint16Data = new Uint16Array(buffer);
            const texture = Utils.uint16ToTexture(uint16Data, tile.tileWidth, tile.tileHeight);
            
            cached.texture = texture;
            cached.loading = false;
            
            // Sync immediately, but don't fetch again
            this._syncTileSprite(tile, key, false);
            this.onRequestRender();
          })
          .catch(err => {
            this.tiles.delete(key); // Retry later
            console.warn("Tile fetch failed", err);
          });
      }

      updateDisplaySettings(settings) {
        // Settings: { min, max, gamma, opacity, colormapName }
        if (settings.min !== undefined) this.uniforms.uMin = settings.min / 65535; // Normalize
        if (settings.max !== undefined) this.uniforms.uMax = settings.max / 65535; // Normalize
        if (settings.gamma !== undefined) this.uniforms.uGamma = settings.gamma;
        if (settings.opacity !== undefined) {
          this.uniforms.uOpacity = settings.opacity;
          // this.container.alpha = settings.opacity; // Optional: helps with culling
        }
        if (settings.colormap) {
          this.uniforms.uColormap = Utils.createColormapTexture(settings.colormap);
        }

        if (settings.blending === 'additive') {
          this.tileContainer.blendMode = PIXI.BLEND_MODES.ADD;
        } else {
          this.tileContainer.blendMode = PIXI.BLEND_MODES.NORMAL;
        }

        // TODO Ideally we have a single source of truth that the uniforms react to, because this
        // double updating feels redundant
        this.min = settings.min
        this.max = settings.max
        this.gamma = settings.gamma
        this.opacity = settings.opacity
        this.colormap = settings.colormap
        this.blending = settings.blending


        this.onRequestRender();
      }

      /** Main Update Loop for this object */
      render(app, cameraState) {
        // Update Transform
        this.container.x = this.x;
        this.container.y = this.y;
        this.container.scale.set(this.scale);


        this.overlayGraphics.clear();
        if (this.selected) {
          // Invert visual scale for line width so it stays constant 2px on screen
          const lineWidth = 2 / (cameraState.scale * this.scale);
          this.overlayGraphics.lineStyle(lineWidth, Config.COLORS.SELECTION, 1);
          this.overlayGraphics.drawRect(0, 0, this.width, this.height);
        }

        this.textLabel.text = `${(this.scale * 100).toFixed(0)}%`;
        this.textLabel.x = 5 / this.scale;
        this.textLabel.y = 20 / this.scale;
        this.textLabel.scale.set(1 / this.scale);

        // LOD Calculation
        this.computeVisibleTiles(app.screen, cameraState);
      }
    }

    // ==========================================
    // MODULE 3: Input Controller
    // ==========================================
    class InputController {
      constructor(domElement, state, renderFn) {
        this.el = domElement;
        this.state = state;
        this.requestRender = renderFn;
        
        this._bindEvents();
      }

      _bindEvents() {
        // [FIX]: Added 'wheel' to passive: false to prevent browser zooming
        this.el.addEventListener('wheel', this._onWheel.bind(this), { passive: false });
        this.el.addEventListener('mousedown', this._onMouseDown.bind(this));
        window.addEventListener('mousemove', this._onMouseMove.bind(this));
        window.addEventListener('mouseup', this._onMouseUp.bind(this));
        // Prevent context menu
        this.el.addEventListener('contextmenu', e => e.preventDefault());
      }

      _onWheel(e) {
        e.preventDefault();
        const { camera } = this.state;

        if (e.ctrlKey) {
          // Zoom
          const zoomIntensity = 0.012;
          const delta = -e.deltaY;
          const newScale = Math.min(4.0, Math.max(0.01, camera.scale * (1 + delta * zoomIntensity)))
          
          const rect = this.el.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          // Pivot Zoom Math
          camera.offsetX -= (mx - camera.offsetX) * (newScale / camera.scale - 1);
          camera.offsetY -= (my - camera.offsetY) * (newScale / camera.scale - 1);
          camera.scale = newScale;
        } else {
          // Pan
          camera.offsetX -= e.deltaX;
          camera.offsetY -= e.deltaY;
        }
        this.requestRender();
      }

      _onMouseDown(e) {
        const { camera, selection, input } = this.state;
        const worldPos = Utils.screenToWorld(e.clientX, e.clientY, camera);

        // 1. Pan Action
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
          input.mode = 'PANNING';
          input.startPos = { x: e.clientX, y: e.clientY };
          return;
        }

        // 2. Left Click (Select or Drag)
        if (e.button === 0) {
          // Hit Test (Reverse order for Z-index)
          let clickedImage = null;
          for (let i = this.state.scene.images.length - 1; i >= 0; i--) {
            if (this.state.scene.images[i].hitTest(worldPos.x, worldPos.y)) {
              clickedImage = this.state.scene.images[i];
              break;
            }
          }

          if (clickedImage) {
            this._handleImageClick(clickedImage, e);
          } else {
            // Clicked Empty Space -> Box Select
            if (!e.metaKey && !e.ctrlKey) selection.active.clear();
            input.mode = 'BOX_SELECT';
            selection.box = { active: true, startX: e.clientX, startY: e.clientY, width: 0, height: 0 };
          }
          this.requestRender();
        }
      }

      _handleImageClick(img, e) {
        const { selection, input } = this.state;
        const isMulti = e.metaKey || e.ctrlKey;
        const isSelected = selection.active.has(img);

        if (isMulti) {
          isSelected ? selection.active.delete(img) : selection.active.add(img);
        } else if (!isSelected) {
          selection.active.clear();
          selection.active.add(img);
        }

        input.mode = 'DRAGGING';
        input.startPos = { x: e.clientX, y: e.clientY };
      }

      _onMouseMove(e) {
        const { input, camera, selection } = this.state;
        if (input.mode === 'IDLE') return;

        let dirty = false;

        if (input.mode === 'PANNING') {
          camera.offsetX += e.clientX - input.startPos.x;
          camera.offsetY += e.clientY - input.startPos.y;
          input.startPos = { x: e.clientX, y: e.clientY };
          dirty = true;
        } 
        else if (input.mode === 'DRAGGING') {
          const dx = (e.clientX - input.startPos.x) / camera.scale;
          const dy = (e.clientY - input.startPos.y) / camera.scale;
          
          selection.active.forEach(img => {
            img.x += dx;
            img.y += dy;
          });
          
          input.startPos = { x: e.clientX, y: e.clientY };
          dirty = true;
        } 
        else if (input.mode === 'BOX_SELECT') {
          selection.box.width = e.clientX - selection.box.startX;
          selection.box.height = e.clientY - selection.box.startY;
          dirty = true;
        }

        if (dirty) this.requestRender();
      }

      _onMouseUp() {
        const { input, selection, camera, scene } = this.state;
        
        if (input.mode === 'BOX_SELECT') {
          this._finalizeBoxSelection();
        }

        input.mode = 'IDLE';
        selection.box.active = false;
        this.requestRender();
      }

      _finalizeBoxSelection() {
        const { selection, camera, scene } = this.state;
        const b = selection.box;
        
        // Normalize rect (handle negative width/height)
        const sx = b.width > 0 ? b.startX : b.startX + b.width;
        const sy = b.height > 0 ? b.startY : b.startY + b.height;
        const sw = Math.abs(b.width);
        const sh = Math.abs(b.height);

        const tl = Utils.screenToWorld(sx, sy, camera);
        const br = Utils.screenToWorld(sx + sw, sy + sh, camera);

        const worldBox = { x: tl.x, y: tl.y, w: br.x - tl.x, h: br.y - tl.y };

        scene.images.forEach(img => {
          const imgBox = { x: img.x, y: img.y, w: img.width * img.scale, h: img.height * img.scale };
          if (Utils.rectsIntersect(worldBox, imgBox)) {
            selection.active.add(img);
          }
        });
      }
    }

    // ==========================================
    // MODULE 4: Layout Engine
    // ==========================================
    const LayoutEngine = {
      arrangeGrid(images) {
        if (images.length === 0) return;
        const padding = 50;
        const cols = Math.ceil(Math.sqrt(images.length));
        const colWidths = [];
        const rowHeights = [];

        // Measure
        images.forEach((img, i) => {
          const c = i % cols;
          const r = Math.floor(i / cols);
          const w = img.width * img.scale;
          const h = img.height * img.scale;
          colWidths[c] = Math.max(colWidths[c] || 0, w);
          rowHeights[r] = Math.max(rowHeights[r] || 0, h);
        });

        // Position
        images.forEach((img, i) => {
          const c = i % cols;
          const r = Math.floor(i / cols);
          let x = 0, y = 0;
          for (let k = 0; k < c; k++) x += colWidths[k] + padding;
          for (let k = 0; k < r; k++) y += rowHeights[k] + padding;
          img.x = x;
          img.y = y;
        });
      },

      calculateFit(images, screenW, screenH) {
         if (images.length === 0) return null;
         let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
         
         images.forEach(img => {
           minX = Math.min(minX, img.x);
           minY = Math.min(minY, img.y);
           maxX = Math.max(maxX, img.x + img.width * img.scale);
           maxY = Math.max(maxY, img.y + img.height * img.scale);
         });

         const w = maxX - minX;
         const h = maxY - minY;
         const padding = 40;
         
         const scale = Math.min(
           (screenW - padding * 2) / w,
           (screenH - padding * 2) / h
         );

         const centerX = (minX + maxX) / 2;
         const centerY = (minY + maxY) / 2;

         return {
           scale,
           offsetX: screenW / 2 - centerX * scale,
           offsetY: screenH / 2 - centerY * scale
         };
      }
    };

    // ==========================================
    // MODULE 5: Main Application (Vue)
    // ==========================================
    createApp({
      setup() {
        // --- Structured Reactive State ---
        const state = reactive({
          camera: { offsetX: 0, offsetY: 0, scale: 1 },
          input: { 
            mode: 'IDLE', // IDLE, PANNING, DRAGGING, BOX_SELECT
            startPos: { x: 0, y: 0 } 
          },
          selection: {
            active: new Set(), // Set<DeepZoomImage>
            box: { active: false, startX: 0, startY: 0, width: 0, height: 0 }
          },
          scene: {
            images: [] // Array<DeepZoomImage>
          }
        });

        const settings = ref({
          min: 0,
          max: 1,
          gamma: 1.0,
          opacity: 1.0,
          colormap: 'gray',
          blending: 'translucent',
        })

        // --- Pixi Setup ---
        let app = null;
        let inputController = null;
        const worldContainer = new PIXI.Container();
        const selectionGraphics = new PIXI.Graphics();
        const gridGraphics = new PIXI.Graphics();
        let renderPending = false;

        // --- Render Loop ---
        function requestRender() {
          if (!renderPending) {
            renderPending = true;
            requestAnimationFrame(renderScene);
          }
        }

        function renderScene() {
          renderPending = false;
          if (!app) return;

          // 1. Sync Camera
          worldContainer.x = state.camera.offsetX;
          worldContainer.y = state.camera.offsetY;
          worldContainer.scale.set(state.camera.scale);

          // 1b. Update Grid Position for Pan Visual
          // updateGrid();

          // 2. Render Images
          state.scene.images.forEach(img => img.render(app, state.camera));

          // 3. Render Selection Box
          selectionGraphics.clear();
          if (state.selection.box.active) {
            const { startX, startY, width, height } = state.selection.box;

            // Account for 'backwards' selection
            const x = width < 0 ? startX + width : startX
            const y = height < 0 ? startY + height : startY
            const w = Math.abs(width)
            const h = Math.abs(height)

            selectionGraphics.beginFill(Config.COLORS.SELECTION, 0.2);
            selectionGraphics.lineStyle(1, Config.COLORS.SELECTION, 0.8);
            selectionGraphics.drawRect(x, y, w, h);
            selectionGraphics.endFill();
          }

          // 4. Update HUD Elements
          updateContextPopup();

          // 5. Pixi Draw
          app.renderer.render(app.stage);
        }

        // --- Grid Background ---
        function updateGrid() {
          const gridColor = 0xFFFFFF;
          const scale = state.camera.scale;

          gridGraphics.clear();

          // Define grid levels: each level has a size and ideal zoom range
          const gridLevels = [
            { size: 10, minZoom: 2, maxZoom: Infinity },
            { size: 50, minZoom: 0.5, maxZoom: 4 },
            { size: 250, minZoom: 0.1, maxZoom: 1 },
            { size: 1000, minZoom: 0, maxZoom: 0.2 }
          ];

          // Calculate visible world bounds
          const startX = Math.floor(-state.camera.offsetX / state.camera.scale / Math.max(...gridLevels.map(g => g.size))) * Math.max(...gridLevels.map(g => g.size));
          const startY = Math.floor(-state.camera.offsetY / state.camera.scale / Math.max(...gridLevels.map(g => g.size))) * Math.max(...gridLevels.map(g => g.size));
          const maxSize = Math.max(...gridLevels.map(g => g.size));
          const endX = startX + (app.screen.width / scale) + maxSize * 2;
          const endY = startY + (app.screen.height / scale) + maxSize * 2;

          // Draw each grid level with fade based on zoom
          gridLevels.forEach(({ size, minZoom, maxZoom }) => {
            // Calculate opacity: fade in when zoom is ideal, fade out when not
            let alpha = 0;
            if (scale >= minZoom && scale <= maxZoom) {
              // Ideal range: full opacity
              alpha = 0.3;
            } else if (scale < minZoom) {
              // Zoomed in past ideal: fade out
              alpha = 0.3 * Math.max(0, 1 - (minZoom - scale) / minZoom);
            } else {
              // Zoomed out past ideal: fade out
              alpha = 0.3 * Math.max(0, 1 - (scale - maxZoom) / maxZoom);
            }

            if (alpha < 0.01) return; // Skip if essentially invisible

            gridGraphics.beginFill(gridColor, alpha);

            // Draw dots at grid intersections
            const startGridX = Math.floor(startX / size) * size;
            const startGridY = Math.floor(startY / size) * size;
            const dotRadius = 1.5;

            // for (let x = startGridX; x < endX; x += 100) {
            //   for (let y = startGridY; y < endY; y += 100) {
            //     gridGraphics.drawCircle(x, y, dotRadius);
            //   }
            // }

            gridGraphics.endFill();
          });
        }

        // --- DOM HUD Logic ---
        function updateContextPopup() {
          const popup = document.getElementById('context-popup-bar');
          if (!popup) return;

          if (state.selection.active.size === 0) {
            popup.classList.add('hidden');
            return;
          }

          // Calculate bounds of selection on screen
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const img of state.selection.active) {
             const x1 = img.x * state.camera.scale + state.camera.offsetX;
             const y1 = img.y * state.camera.scale + state.camera.offsetY;
             const w = img.width * img.scale * state.camera.scale;
             const h = img.height * img.scale * state.camera.scale;
             
             minX = Math.min(minX, x1);
             minY = Math.min(minY, y1);
             maxX = Math.max(maxX, x1 + w);
             maxY = Math.max(maxY, y1 + h);
          }

          const centerX = (minX + maxX) / 2;
          const topY = minY;
          
          // Clamp logic
          const pW = popup.offsetWidth, pH = popup.offsetHeight;
          const pad = 12;
          let left = Math.max(pW/2 + pad, Math.min(window.innerWidth - pW/2 - pad, centerX));
          let top = Math.max(pad, Math.min(window.innerHeight - pH - pad, topY - pH - 10));

          popup.style.left = `${left}px`;
          popup.style.top = `${top}px`;
          popup.classList.remove('hidden');
        }

        // --- Actions ---
        function addImage(filename) {
          fetch(`${Config.BASE_URL}/file/${encodeURI(filename)}`)
            .then(res => res.json())
            .then(metadata => {
              const img = new DeepZoomImage(0, 0, { filename, ...metadata }, requestRender);
              state.scene.images.push(img);
              worldContainer.addChild(img.container);
              requestRender();
            })
            .catch(e => console.error(e));
        }

        function layoutGrid() {
          LayoutEngine.arrangeGrid(state.scene.images);
          fitAll();
        }

        function fitAll() {
          const newCam = LayoutEngine.calculateFit(
            state.scene.images, app.screen.width, app.screen.height
          );
          if (newCam) {
            Object.assign(state.camera, newCam);
            requestRender();
          }
        }

        function updateSelection() {
          state.selection.active.forEach((img) => {
            img.updateDisplaySettings(settings.value)
          })
        }

        // --- Lifecycle ---
        onMounted(() => {
          app = new PIXI.Application({
            resizeTo: document.getElementById('app'),
            backgroundColor: 0x000000,
            antialias: true,
            autoStart: false
          });
          document.getElementById('app').appendChild(app.view);
          
          // Layers
          worldContainer.addChild(gridGraphics); // Grid in world space, so it pans
          app.stage.addChild(worldContainer);
          app.stage.addChild(selectionGraphics); // Draw UI on top of World

          // Initialize Input Controller
          inputController = new InputController(app.view, state, requestRender);

          // Keyboard Shortcuts
          window.addEventListener('keydown', e => {
            if (e.code === 'KeyF') fitAll();
            if (e.code === 'KeyG') layoutGrid();
          });
          
          // Watchers for Selection State Visuals
          watch(() => Array.from(state.selection.active), () => {
            // Update "Selected" property on objects for render loop
            state.scene.images.forEach(img => {
              const wasSelected = img.selected;
              img.selected = state.selection.active.has(img);
              // Z-Index Hack: Bring selected to front of Pixi Container
              if (img.selected && !wasSelected) {
                worldContainer.removeChild(img.container);
                worldContainer.addChild(img.container);
              }
            });
            requestRender();

            // When selection changes, the popup also needs to change
            if (state.selection.active.size > 0) {
              const [first] = state.selection.active
              settings.value.max = first.max
              settings.value.gamma = first.gamma
              settings.value.opacity = first.opacity
              settings.value.colormap = first.colormap
            }
          });

          // Bootstrap Scene
          addImage('002_IDv3__aa855_s05_c0.tif');
          addImage('002_IDv3__aa855_s05_c1.tif');
          // addImage('002_IDv3__aa855_s05_c2.tif');
          // addImage('002_IDv3__aa855_s05_c3.tif');
          setTimeout(layoutGrid, 1000);
        });

        // Expose to Template
        return {
          ...toRefs(state),
          layoutGrid,
          fitAll,
          settings,
          updateSelection,
        };
      }
    }).mount('#app');
  </script>
</body>
</html>