<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pan/Zoom Canvas</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
    }
    #app {
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #2c2c34;
    }

    /* ViewportHUD - overlay that floats above canvas */
    viewport-hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: block;
    }

    viewport-hud > * {
      pointer-events: auto;
    }

    .hud-top-left {
      position: absolute;
      top: 12px;
      left: 12px;
    }

    .hud-bottom-right {
      position: absolute;
      bottom: 12px;
      right: 12px;
    }

    .hud-label {
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }

    .hud-btn {
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 12px;
      cursor: pointer;
    }

    .hud-btn:hover {
      background: rgba(0, 0, 0, 0.8);
    }
  </style>
</head>
<body>
  <div id="app">
    <canvas ref="canvas"></canvas>
    <viewport-hud>
      <div class="hud-top-left">
        <span id="zoom-label" class="hud-label">100%</span>
      </div>
      <div class="hud-bottom-right">
        <button id="fit-btn" class="hud-btn">Fit All (Space)</button>
      </div>
    </viewport-hud>
  </div>

  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script>
    const { createApp, onMounted, reactive } = Vue;

    class DraggableImage {
      constructor(x, y, width, height, tileSize = 256, maxZoomLevel = 8) {
        this.x = x;
        this.y = y;
        this.scale = 1;
        this.width = width;
        this.height = height;

        this.tileSize = tileSize;
        this.maxZoomLevel = maxZoomLevel;

        this.isDragging = false;
        this.dragLastX = 0;
        this.dragLastY = 0;

        this.tiles = new Map();
        this.visibleTiles = [];
      }

      containsPoint(px, py) {
        return px >= this.x && px <= this.x + this.width * this.scale &&
               py >= this.y && py <= this.y + this.height * this.scale;
      }

      // Determine which zoom level to use based on current scale
      getZoomLevel() {
        const level = Math.floor(Math.log2(1 / this.scale));
        return Math.min(Math.max(level, 0), this.maxZoomLevel);
      }

      computeVisibleTiles(ctx, state) {
        // 1. Combined zoom
        const worldScale = state.scale * this.scale;

        // Determine which LOD to use
        let level = Math.floor(Math.log2(1 / worldScale));
        level = Math.min(Math.max(level, 0), this.maxZoomLevel);
        
        const effectiveTileSize = this.tileSize * Math.pow(2, level);
        console.log('level', level, effectiveTileSize)

        // 2. Convert the viewport from screen → world → image space
        // Screen rect: (0,0) → (canvas.width, canvas.height)
        const sx0 = 0;
        const sy0 = 0;
        const sx1 = ctx.canvas.width;
        const sy1 = ctx.canvas.height;

        // Screen → World
        const wx0 = (sx0 - state.offsetX) / state.scale;
        const wy0 = (sy0 - state.offsetY) / state.scale;
        const wx1 = (sx1 - state.offsetX) / state.scale;
        const wy1 = (sy1 - state.offsetY) / state.scale;

        // World → Image space
        const ix0 = (wx0 - this.x) / this.scale;
        const iy0 = (wy0 - this.y) / this.scale;
        const ix1 = (wx1 - this.x) / this.scale;
        const iy1 = (wy1 - this.y) / this.scale;

        // 3. Clamp to image boundaries
        const cx0 = Math.max(0, ix0);
        const cy0 = Math.max(0, iy0);
        const cx1 = Math.min(this.width, ix1);
        const cy1 = Math.min(this.height, iy1);

        // 4. Tile index ranges
        const tx0 = Math.floor(cx0 / effectiveTileSize);
        const ty0 = Math.floor(cy0 / effectiveTileSize);
        const tx1 = Math.floor(cx1 / effectiveTileSize);
        const ty1 = Math.floor(cy1 / effectiveTileSize);

        const tiles = [];
        for (let ty = ty0; ty <= ty1; ty++) {
          for (let tx = tx0; tx <= tx1; tx++) {
            tiles.push({ tx, ty, level, tileSize: effectiveTileSize });
          }
        }

        this.visibleTiles = tiles;
        return tiles;
      }

      // Draw placeholder tiles for now
      drawTiles(ctx, state) {
        ctx.save();
        ctx.strokeStyle = '#999';
        ctx.font = '12px monospace';

        for (const { tx, ty, level, tileSize } of this.visibleTiles) {
          const worldX = this.x + tx * tileSize * this.scale;
          const worldY = this.y + ty * tileSize * this.scale;
          const size = tileSize * this.scale;
          const fontsize = 24 * Math.pow(2, level)

          ctx.strokeRect(worldX, worldY, size, size);
          ctx.font = `${fontsize}px monospace`
          ctx.fillText(`L${level} (${tx},${ty})`, worldX + fontsize, worldY + fontsize);
        }

        ctx.restore();
      }

      draw(ctx, state) {
        ctx.save();

        // Background placeholder image extents
        ctx.fillStyle = 'rgba(100, 100, 150, 0.3)';
        ctx.fillRect(this.x, this.y, this.width * this.scale, this.height * this.scale);

        ctx.strokeStyle = '#4a9eff';
        ctx.lineWidth = 2 / ctx.canvas.width;
        ctx.strokeRect(this.x, this.y, this.width * this.scale, this.height * this.scale);

        ctx.fillStyle = '#aaa';
        ctx.font = '14px monospace';
        ctx.fillText(`${(this.scale * 100).toFixed(0)}%`, this.x + 5, this.y + 20);

        ctx.restore();

        // Phase 1: draw computed tiles
        this.drawTiles(ctx, state);
      }
    }


    createApp({
      setup() {
        const state = reactive({
          offsetX: 0,
          offsetY: 0,
          scale: 1,
          isDragging: false,
          lastX: 0,
          lastY: 0,
          pointers: {},
          pinchStartDistance: 0,
          pinchStartScale: 1,
          draggableImages: [
            new DraggableImage(20, 50, 100, 100),
            new DraggableImage(200, 150, 400, 300),
            new DraggableImage(300, 200, 10000, 7000),
          ],
          activeDraggableImage: null
        });

        let canvas, ctx;
        const DEBUG = false

        function draw() {
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          ctx.setTransform(state.scale, 0, 0, state.scale, state.offsetX, state.offsetY);
          
          if (DEBUG) {
            ctx.setTransform(1, 0, 0, 1, 0, 0)
            ctx.strokeStyle = '#F00'
            ctx.lineWidth = 2
            ctx.strokeRect(
              0 - state.offsetX,
              0 - state.offsetY,
              canvas.width / state.scale,
              canvas.height / state.scale,
            )
          }

          state.draggableImages.forEach(img => img.computeVisibleTiles(ctx, state));
          state.draggableImages.forEach(img => img.draw(ctx, state));

          // Update HUD
          const zoomLabel = document.getElementById('zoom-label');
          if (zoomLabel) zoomLabel.textContent = `${(state.scale * 100).toFixed(0)}%`;
        }

        function getPointerDistance(p1, p2) {
          return Math.hypot(p2.x - p1.x, p2.y - p1.y);
        }

        function zoomToFitAllImages() {
          if (state.draggableImages.length === 0) return;

          // Calculate bounding box of all images in world space
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const img of state.draggableImages) {
            minX = Math.min(minX, img.x);
            minY = Math.min(minY, img.y);
            maxX = Math.max(maxX, img.x + img.width * img.scale);
            maxY = Math.max(maxY, img.y + img.height * img.scale);
          }

          const boundsWidth = maxX - minX;
          const boundsHeight = maxY - minY;
          const padding = 40;

          // Calculate scale to fit bounds in canvas with padding
          const scaleX = (canvas.width - padding * 2) / boundsWidth;
          const scaleY = (canvas.height - padding * 2) / boundsHeight;
          state.scale = Math.min(scaleX, scaleY);

          // Center the bounds in the canvas
          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          state.offsetX = canvas.width / 2 - centerX * state.scale;
          state.offsetY = canvas.height / 2 - centerY * state.scale;

          draw();
        }

        function screenToCanvasCoords(screenX, screenY) {
          const rect = canvas.getBoundingClientRect();
          let sx = (screenX - rect.left) / state.scale - state.offsetX / state.scale;
          let sy = (screenY - rect.top) / state.scale - state.offsetY / state.scale;
          return { sx, sy };
        }

        onMounted(() => {
          canvas = document.querySelector('canvas');
          ctx = canvas.getContext('2d');

          // HIGH-DPI CANVAS RESIZE (Fully Correct)
          function resize() {
            const rect = canvas.getBoundingClientRect();
            // const dpr = window.devicePixelRatio || 1; // TODO get retina working
            const dpr = 1

            // Internal pixel buffer size (physical pixels)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Reset and scale context to map CSS pixels to physical pixels
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.scale(dpr, dpr);

            draw();
          }

          window.addEventListener('resize', resize);
          resize();

          // Prevent the context menu from popping up
          canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
          });

          // Keyboard shortcuts
          window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
              e.preventDefault();
              zoomToFitAllImages();
            }
          });

          // HUD button
          document.getElementById('fit-btn').addEventListener('click', zoomToFitAllImages);

          // Mouse drag
          canvas.addEventListener('mousedown', e => {
            const { sx, sy } = screenToCanvasCoords(e.clientX, e.clientY);

            // Only allow mouse drag with middle click
            if (e.button == 1 && e.buttons == 4) {
              state.isDragging = true;
              state.lastX = e.clientX;
              state.lastY = e.clientY;
              return
            }

            let hitImage = null;
            if (e.button == 0 && e.buttons == 1) {
              for (let img of state.draggableImages) {
                if (img.containsPoint(sx, sy)) {
                  hitImage = img;
                  break;
                }
              }
            }

            if (hitImage) {
              state.activeDraggableImage = hitImage;
              hitImage.isDragging = true;
              hitImage.dragLastX = e.clientX;
              hitImage.dragLastY = e.clientY;
            }
          });

          canvas.addEventListener('mousemove', e => {
            if (e.button == 0 && e.buttons == 4) {
              const dx = e.clientX - state.lastX;
              const dy = e.clientY - state.lastY;
              state.offsetX += dx;
              state.offsetY += dy;
              state.lastX = e.clientX;
              state.lastY = e.clientY;
              draw();
            }

            if (state.activeDraggableImage) {
              const dx = e.clientX - state.activeDraggableImage.dragLastX;
              const dy = e.clientY - state.activeDraggableImage.dragLastY;

              state.activeDraggableImage.x += dx / state.scale;
              state.activeDraggableImage.y += dy / state.scale;

              state.activeDraggableImage.dragLastX = e.clientX;
              state.activeDraggableImage.dragLastY = e.clientY;

              draw();
            }
          });

          canvas.addEventListener('mouseup', () => {
            state.isDragging = false;
            if (state.activeDraggableImage) {
              state.activeDraggableImage.isDragging = false;
              state.activeDraggableImage = null;
            }
          });

          canvas.addEventListener('mouseleave', () => {
            state.isDragging = false;
            if (state.activeDraggableImage) {
              state.activeDraggableImage.isDragging = false;
              state.activeDraggableImage = null;
            }
          });

          // Zoom / scroll
          canvas.addEventListener('wheel', e => {
            e.preventDefault();

            if (e.ctrlKey) {
              const zoomIntensity = 0.017;
              const delta = e.deltaY * -zoomIntensity;
              const newScale = Math.max(0.05, state.scale * (1 + delta));

              const rect = canvas.getBoundingClientRect();
              const mx = e.clientX - rect.left;
              const my = e.clientY - rect.top;

              state.offsetX -= (mx - state.offsetX) * (newScale / state.scale - 1);
              state.offsetY -= (my - state.offsetY) * (newScale / state.scale - 1);

              state.scale = newScale;
              console.log(state.scale)
              draw();
            } else {
              const panIntensity = 2.3;
              state.offsetX += e.deltaX * -panIntensity;
              state.offsetY += e.deltaY * -panIntensity;
              draw();
            }
          }, { passive: false });

          // Pointer events for pinch
          canvas.addEventListener('pointerdown', e => {
            state.pointers[e.pointerId] = e;

            if (Object.keys(state.pointers).length === 2) {
              const [p1, p2] = Object.values(state.pointers);
              state.pinchStartDistance = getPointerDistance(p1, p2);
              state.pinchStartScale = state.scale;
            }
          });

          canvas.addEventListener('pointermove', e => {
            if (!(e.pointerId in state.pointers)) return;

            state.pointers[e.pointerId] = e;

            if (Object.keys(state.pointers).length === 2) {
              const [p1, p2] = Object.values(state.pointers);
              const newDistance = getPointerDistance(p1, p2);
              state.scale = state.pinchStartScale * (newDistance / state.pinchStartDistance);
              draw();
            }
          });

          canvas.addEventListener('pointerup', e => delete state.pointers[e.pointerId]);
          canvas.addEventListener('pointercancel', e => delete state.pointers[e.pointerId]);
        });

        return {};
      }
    }).mount('#app');
  </script>
</body>
</html>
