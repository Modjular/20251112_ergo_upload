<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>DeepZoom</title>
  <style>
    /* --- CSS Styles (Unchanged) --- */
    html, body { margin: 0; height: 100%; overflow: hidden; background: #2c2c34; }
    #app { width: 100%; height: 100%; touch-action: none; position: relative; }
    canvas { display: block; width: 100%; height: 100%; }
    viewport-hud { position: absolute; inset: 0; pointer-events: none; display: block; z-index: 10; }
    viewport-hud > * { pointer-events: auto; }
    .hud-top-left { position: absolute; top: 12px; left: 12px; }
    .hud-bottom-right { position: absolute; bottom: 12px; right: 12px; }
    .hud-label { background: rgba(0,0,0,0.6); color: #fff; padding: 4px 8px; border-radius: 4px; font-family: monospace; font-size: 12px; }
    .hud-btn { background: rgba(0,0,0,0.6); color: #fff; border: none; padding: 6px 12px; border-radius: 4px; font-family: sans-serif; font-size: 12px; cursor: pointer; margin-left: 1ch; }
    .hud-btn:hover { background: rgba(0,0,0,0.8); }
    .context-popup-bar { position: absolute; display: flex; align-items: center; gap: 4px; padding: 6px 8px; background: #2c2c34; border-radius: 8px; box-shadow: 0 2px 12px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.1); pointer-events: auto; transform: translateX(-50%); z-index: 20; }
    .context-popup-bar.hidden { display: none; }
    .context-popup-bar button { background: transparent; border: none; color: #fff; padding: 6px 12px; border-radius: 4px; font-family: sans-serif; font-size: 13px; cursor: pointer; white-space: nowrap; }
    .context-popup-bar button:hover { background: rgba(255,255,255,0.1); }
  </style>
</head>
<body>
  <div id="app">
    <viewport-hud>
      <div class="hud-top-left">
        <span id="zoom-label" class="hud-label">{{ (camera.scale * 100).toFixed(0) }}%</span>
      </div>
      <div class="hud-bottom-right">
        <button id="grid-btn" class="hud-btn" @click="layoutGrid">Grid (G)</button>
        <button id="fit-btn" class="hud-btn" @click="fitAll">Fit All (F)</button>
      </div>

      <!-- Context Popup bar -->
      <div id="context-popup-bar" class="context-popup-bar hidden">
        <button id="popup-action-btn">Action</button>
      </div>
    </viewport-hud>
  </div>

  <!-- <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script> -->
  <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script> -->
  <script src="/assets/js/vue.min.js"></script>
  <script src="/assets/js/pixi.min.js"></script>

  <script>
    const { createApp, onMounted, reactive, watch, toRefs } = Vue;

    // ==========================================
    // MODULE 1: Constants & Utilities
    // ==========================================
    const Config = {
      BASE_URL: 'http://127.0.0.1:8000',
      TILE_SIZE: 256,
      MAX_ZOOM: 4,
      LOD_BIAS: 2,
      COLORS: {
        BG: 0x646496,
        SELECTION: 0x4a9eff
      }
    };

    const MathUtils = {
      /** Axis-Aligned Bounding Box intersection */
      rectsIntersect(r1, r2) {
        return !(r2.x > r1.x + r1.w || 
                 r2.x + r2.w < r1.x || 
                 r2.y > r1.y + r1.h || 
                 r2.y + r2.h < r1.y);
      },

      /** Screen pixel -> World coordinate conversion */
      screenToWorld(screenX, screenY, cameraState) {
        return {
          x: (screenX - cameraState.offsetX) / cameraState.scale,
          y: (screenY - cameraState.offsetY) / cameraState.scale
        };
      },
      
      /** * 16-bit array to Texture conversion.
       * [OPTIMIZATION]: This creates a new Canvas/Context for every single tile fetch.
       * For high-throughput apps, use a WebGL shader to render Uint16 directly,
       * or use an OffscreenCanvas pool to reduce GC overhead.
       */
      uint16ToTexture(uint16Data, width, height) {
        const bufferCanvas = document.createElement('canvas');
        bufferCanvas.width = width;
        bufferCanvas.height = height;
        const ctx = bufferCanvas.getContext('2d');
        const imageData = ctx.createImageData(width, height);
        const rgba = imageData.data;

        // [FIX]: Hardcoded normalization range (0-4000). 
        // Ideally, this should come from image metadata (histogram).
        let min = 0, max = 4000;
        const range = max - min || 1;

        for (let i = 0; i < uint16Data.length; i++) {
          const val = Math.floor(((uint16Data[i] - min) / range) * 255);
          const idx = i * 4;
          rgba[idx] = val;     // R
          rgba[idx + 1] = val; // G
          rgba[idx + 2] = val; // B
          rgba[idx + 3] = 255; // Alpha
        }

        ctx.putImageData(imageData, 0, 0);
        return PIXI.Texture.from(bufferCanvas);
      }
    };

    // ==========================================
    // MODULE 2: Core Domain Logic
    // ==========================================

    /**
     * DeepZoomImage (Refactored DraggableImage)
     * Encapsulates the Pixi display logic and the Tile LOD mathematics.
     */
    class DeepZoomImage {
      constructor(x, y, metadata, onRequestRender) {
        // Data Model
        this.x = x;
        this.y = y;
        this.width = metadata.shape[1]; // shape is usually [y, x]
        this.height = metadata.shape[0];
        this.scale = 1;
        this.selected = false;
        this.metadata = metadata;
        
        // Dependencies
        this.onRequestRender = onRequestRender;

        // State
        this.tiles = new Map(); // Cache
        
        // Visuals (Pixi)
        this.container = new PIXI.Container();
        this._initVisuals();
      }

      _initVisuals() {
        this.bgGraphics = new PIXI.Graphics();
        this.tileContainer = new PIXI.Container();
        this.tileContainer.sortableChildren = true; // Essential for LOD stacking
        this.overlayGraphics = new PIXI.Graphics();
        
        this.textLabel = new PIXI.Text('', {
          fontFamily: 'monospace', fontSize: 14, fill: 0xaaaaaa,
        });
        this.overlayGraphics.addChild(this.textLabel);

        this.container.addChild(this.bgGraphics, this.tileContainer, this.overlayGraphics);
      }

      /** Checks if point is inside this image (World Coords) */
      hitTest(wx, wy) {
        return wx >= this.x && wx <= this.x + this.width * this.scale &&
               wy >= this.y && wy <= this.y + this.height * this.scale;
      }

      /**
       * Core LOD Logic (The "Painter's Algorithm").
       * Preserved from original code.
       */
      computeVisibleTiles(appScreen, cameraState) {
        const worldScale = cameraState.scale * this.scale;
        
        // 1. Calculate Target LOD
        let targetLevel = Math.floor(Math.log2(1 / worldScale)) + Config.LOD_BIAS;
        targetLevel = Math.min(Math.max(targetLevel, 0), Config.MAX_ZOOM);

        // 2. Viewport Culling
        const viewportX = -cameraState.offsetX / cameraState.scale;
        const viewportY = -cameraState.offsetY / cameraState.scale;
        const viewportW = appScreen.width / cameraState.scale;
        const viewportH = appScreen.height / cameraState.scale;

        // Convert Viewport to Local Image Space
        const ix0 = (viewportX - this.x) / this.scale;
        const iy0 = (viewportY - this.y) / this.scale;
        const ix1 = (viewportX + viewportW - this.x) / this.scale;
        const iy1 = (viewportY + viewportH - this.y) / this.scale;

        const cx0 = Math.max(0, ix0);
        const cy0 = Math.max(0, iy0);
        const cx1 = Math.min(this.width, ix1);
        const cy1 = Math.min(this.height, iy1);

        const newVisibleKeys = new Set();

        // 3. Recursive Visibility Loop (High Res -> Low Res)
        for (let level = targetLevel; level <= Config.MAX_ZOOM; level++) {
          const effectiveTileSize = Config.TILE_SIZE * Math.pow(2, level);
          const tx0 = Math.floor(cx0 / effectiveTileSize);
          const ty0 = Math.floor(cy0 / effectiveTileSize);
          const tx1 = Math.floor(cx1 / effectiveTileSize);
          const ty1 = Math.floor(cy1 / effectiveTileSize);

          for (let ty = ty0; ty <= ty1; ty++) {
            for (let tx = tx0; tx <= tx1; tx++) {
              const tileX0 = tx * effectiveTileSize;
              const tileY0 = ty * effectiveTileSize;
              
              const tileWidth = Math.round(Math.min(effectiveTileSize, this.width - tileX0) / Math.pow(2, level));
              const tileHeight = Math.round(Math.min(effectiveTileSize, this.height - tileY0) / Math.pow(2, level));

              if (tileWidth <= 0 || tileHeight <= 0) continue;

              const tileData = { tz: 0, ty, tx, level, effectiveTileSize, tileWidth, tileHeight };
              const key = `L${level}_Z0_${ty}_${tx}`;
              
              newVisibleKeys.add(key);

              // Only fetch if it's the target level
              const shouldFetch = (level === targetLevel);
              this._syncTileSprite(tileData, key, shouldFetch);
            }
          }
        }

        // 4. Cleanup invisible sprites
        for (const [key, data] of this.tiles.entries()) {
          if (!newVisibleKeys.has(key) && data.sprite) {
            data.sprite.visible = false;
          }
        }
      }

      _syncTileSprite(tile, key, shouldFetch) {
        let cached = this.tiles.get(key);

        if (!cached) {
          if (shouldFetch) {
            this.tiles.set(key, { loading: true, sprite: null, texture: null, level: tile.level });
            this._fetchTile(tile, key);
          }
          return;
        }

        // Lazy Sprite Creation
        if (cached.texture && !cached.sprite) {
          const sprite = new PIXI.Sprite(cached.texture);
          this.tileContainer.addChild(sprite);
          cached.sprite = sprite;
        }

        // Update Sprite
        if (cached.sprite) {
          cached.sprite.visible = true;
          cached.sprite.x = tile.tx * tile.effectiveTileSize;
          cached.sprite.y = tile.ty * tile.effectiveTileSize;
          
          const scaleFactor = Math.pow(2, tile.level);
          cached.sprite.width = tile.tileWidth * scaleFactor;
          cached.sprite.height = tile.tileHeight * scaleFactor;
          // [FIX] Ensure proper Z-ordering (High res on top)
          cached.sprite.zIndex = Config.MAX_ZOOM - tile.level;
        }
      }

      _fetchTile(tile, key) {
        // [OPTIMIZATION]: A dedicated request queue/manager would prevent 
        // spamming the server if the user pans quickly.
        fetch(`${Config.BASE_URL}/tile/${encodeURI(this.metadata.filename)}/${key}`)
          .then(res => res.arrayBuffer())
          .then(buffer => {
            // Check if still in cache (might have been culled)
            const cached = this.tiles.get(key);
            if (!cached) return;

            const uint16Data = new Uint16Array(buffer);
            const texture = MathUtils.uint16ToTexture(uint16Data, tile.tileWidth, tile.tileHeight);
            
            cached.texture = texture;
            cached.loading = false;
            cached.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
            
            // Sync immediately, but don't fetch again
            this._syncTileSprite(tile, key, false);
            this.onRequestRender();
          })
          .catch(err => {
            this.tiles.delete(key); // Retry later
            console.warn("Tile fetch failed", err);
          });
      }

      /** Main Update Loop for this object */
      render(app, cameraState) {
        // Update Transform
        this.container.x = this.x;
        this.container.y = this.y;
        this.container.scale.set(this.scale);

        // Update UI Overlays
        this.bgGraphics.clear();
        this.bgGraphics.beginFill(Config.COLORS.BG, 0.3);
        this.bgGraphics.drawRect(0, 0, this.width, this.height);
        this.bgGraphics.endFill();

        this.overlayGraphics.clear();
        if (this.selected) {
          // Invert visual scale for line width so it stays constant 2px on screen
          const lineWidth = 2 / (cameraState.scale * this.scale);
          this.overlayGraphics.lineStyle(lineWidth, Config.COLORS.SELECTION, 1);
          this.overlayGraphics.drawRect(0, 0, this.width, this.height);
        }

        this.textLabel.text = `${(this.scale * 100).toFixed(0)}%`;
        this.textLabel.x = 5 / this.scale;
        this.textLabel.y = 20 / this.scale;
        this.textLabel.scale.set(1 / this.scale);

        // LOD Calculation
        this.computeVisibleTiles(app.screen, cameraState);
      }
    }

    // ==========================================
    // MODULE 3: Input Controller
    // ==========================================
    class InputController {
      constructor(domElement, state, renderFn) {
        this.el = domElement;
        this.state = state;
        this.requestRender = renderFn;
        
        this._bindEvents();
      }

      _bindEvents() {
        // [FIX]: Added 'wheel' to passive: false to prevent browser zooming
        this.el.addEventListener('wheel', this._onWheel.bind(this), { passive: false });
        this.el.addEventListener('mousedown', this._onMouseDown.bind(this));
        window.addEventListener('mousemove', this._onMouseMove.bind(this));
        window.addEventListener('mouseup', this._onMouseUp.bind(this));
        // Prevent context menu
        this.el.addEventListener('contextmenu', e => e.preventDefault());
      }

      _onWheel(e) {
        e.preventDefault();
        const { camera } = this.state;

        if (e.ctrlKey) {
          // Zoom
          const zoomIntensity = 0.012;
          const delta = -e.deltaY;
          const newScale = Math.max(0.01, camera.scale * (1 + delta * zoomIntensity));
          
          const rect = this.el.getBoundingClientRect();
          const mx = e.clientX - rect.left;
          const my = e.clientY - rect.top;

          // Pivot Zoom Math
          camera.offsetX -= (mx - camera.offsetX) * (newScale / camera.scale - 1);
          camera.offsetY -= (my - camera.offsetY) * (newScale / camera.scale - 1);
          camera.scale = newScale;
        } else {
          // Pan
          camera.offsetX -= e.deltaX;
          camera.offsetY -= e.deltaY;
        }
        this.requestRender();
      }

      _onMouseDown(e) {
        const { camera, selection, input } = this.state;
        const worldPos = MathUtils.screenToWorld(e.clientX, e.clientY, camera);

        // 1. Pan Action
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
          input.mode = 'PANNING';
          input.startPos = { x: e.clientX, y: e.clientY };
          return;
        }

        // 2. Left Click (Select or Drag)
        if (e.button === 0) {
          // Hit Test (Reverse order for Z-index)
          let clickedImage = null;
          for (let i = this.state.scene.images.length - 1; i >= 0; i--) {
            if (this.state.scene.images[i].hitTest(worldPos.x, worldPos.y)) {
              clickedImage = this.state.scene.images[i];
              break;
            }
          }

          if (clickedImage) {
            this._handleImageClick(clickedImage, e);
          } else {
            // Clicked Empty Space -> Box Select
            if (!e.metaKey && !e.ctrlKey) selection.active.clear();
            input.mode = 'BOX_SELECT';
            selection.box = { active: true, startX: e.clientX, startY: e.clientY, width: 0, height: 0 };
          }
          this.requestRender();
        }
      }

      _handleImageClick(img, e) {
        const { selection, input } = this.state;
        const isMulti = e.metaKey || e.ctrlKey;
        const isSelected = selection.active.has(img);

        if (isMulti) {
          isSelected ? selection.active.delete(img) : selection.active.add(img);
        } else if (!isSelected) {
          selection.active.clear();
          selection.active.add(img);
        }

        input.mode = 'DRAGGING';
        input.startPos = { x: e.clientX, y: e.clientY };
      }

      _onMouseMove(e) {
        const { input, camera, selection } = this.state;
        if (input.mode === 'IDLE') return;

        let dirty = false;

        if (input.mode === 'PANNING') {
          camera.offsetX += e.clientX - input.startPos.x;
          camera.offsetY += e.clientY - input.startPos.y;
          input.startPos = { x: e.clientX, y: e.clientY };
          dirty = true;
        } 
        else if (input.mode === 'DRAGGING') {
          const dx = (e.clientX - input.startPos.x) / camera.scale;
          const dy = (e.clientY - input.startPos.y) / camera.scale;
          
          selection.active.forEach(img => {
            img.x += dx;
            img.y += dy;
          });
          
          input.startPos = { x: e.clientX, y: e.clientY };
          dirty = true;
        } 
        else if (input.mode === 'BOX_SELECT') {
          selection.box.width = e.clientX - selection.box.startX;
          selection.box.height = e.clientY - selection.box.startY;
          dirty = true;
        }

        if (dirty) this.requestRender();
      }

      _onMouseUp() {
        const { input, selection, camera, scene } = this.state;
        
        if (input.mode === 'BOX_SELECT') {
          this._finalizeBoxSelection();
        }

        input.mode = 'IDLE';
        selection.box.active = false;
        this.requestRender();
      }

      _finalizeBoxSelection() {
        const { selection, camera, scene } = this.state;
        const b = selection.box;
        
        // Normalize rect (handle negative width/height)
        const sx = b.width > 0 ? b.startX : b.startX + b.width;
        const sy = b.height > 0 ? b.startY : b.startY + b.height;
        const sw = Math.abs(b.width);
        const sh = Math.abs(b.height);

        const tl = MathUtils.screenToWorld(sx, sy, camera);
        const br = MathUtils.screenToWorld(sx + sw, sy + sh, camera);

        const worldBox = { x: tl.x, y: tl.y, w: br.x - tl.x, h: br.y - tl.y };

        scene.images.forEach(img => {
          const imgBox = { x: img.x, y: img.y, w: img.width * img.scale, h: img.height * img.scale };
          if (MathUtils.rectsIntersect(worldBox, imgBox)) {
            selection.active.add(img);
          }
        });
      }
    }

    // ==========================================
    // MODULE 4: Layout Engine
    // ==========================================
    const LayoutEngine = {
      arrangeGrid(images) {
        if (images.length === 0) return;
        const padding = 50;
        const cols = Math.ceil(Math.sqrt(images.length));
        const colWidths = [];
        const rowHeights = [];

        // Measure
        images.forEach((img, i) => {
          const c = i % cols;
          const r = Math.floor(i / cols);
          const w = img.width * img.scale;
          const h = img.height * img.scale;
          colWidths[c] = Math.max(colWidths[c] || 0, w);
          rowHeights[r] = Math.max(rowHeights[r] || 0, h);
        });

        // Position
        images.forEach((img, i) => {
          const c = i % cols;
          const r = Math.floor(i / cols);
          let x = 0, y = 0;
          for (let k = 0; k < c; k++) x += colWidths[k] + padding;
          for (let k = 0; k < r; k++) y += rowHeights[k] + padding;
          img.x = x;
          img.y = y;
        });
      },

      calculateFit(images, screenW, screenH) {
         if (images.length === 0) return null;
         let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
         
         images.forEach(img => {
           minX = Math.min(minX, img.x);
           minY = Math.min(minY, img.y);
           maxX = Math.max(maxX, img.x + img.width * img.scale);
           maxY = Math.max(maxY, img.y + img.height * img.scale);
         });

         const w = maxX - minX;
         const h = maxY - minY;
         const padding = 40;
         
         const scale = Math.min(
           (screenW - padding * 2) / w,
           (screenH - padding * 2) / h
         );

         const centerX = (minX + maxX) / 2;
         const centerY = (minY + maxY) / 2;

         return {
           scale,
           offsetX: screenW / 2 - centerX * scale,
           offsetY: screenH / 2 - centerY * scale
         };
      }
    };

    // ==========================================
    // MODULE 5: Main Application (Vue)
    // ==========================================
    createApp({
      setup() {
        // --- Structured Reactive State ---
        const state = reactive({
          camera: { offsetX: 0, offsetY: 0, scale: 1 },
          input: { 
            mode: 'IDLE', // IDLE, PANNING, DRAGGING, BOX_SELECT
            startPos: { x: 0, y: 0 } 
          },
          selection: {
            active: new Set(), // Set<DeepZoomImage>
            box: { active: false, startX: 0, startY: 0, width: 0, height: 0 }
          },
          scene: {
            images: [] // Array<DeepZoomImage>
          }
        });

        // --- Pixi Setup ---
        let app = null;
        let inputController = null;
        const worldContainer = new PIXI.Container();
        const selectionGraphics = new PIXI.Graphics();
        let renderPending = false;

        // --- Render Loop ---
        function requestRender() {
          if (!renderPending) {
            renderPending = true;
            requestAnimationFrame(renderScene);
          }
        }

        function renderScene() {
          renderPending = false;
          if (!app) return;

          // 1. Sync Camera
          worldContainer.x = state.camera.offsetX;
          worldContainer.y = state.camera.offsetY;
          worldContainer.scale.set(state.camera.scale);

          // 2. Render Images
          state.scene.images.forEach(img => img.render(app, state.camera));

          // 3. Render Selection Box
          selectionGraphics.clear();
          if (state.selection.box.active) {
            const { startX, startY, width, height } = state.selection.box;

            // Account for 'backwards' selection
            const x = width < 0 ? startX + width : startX
            const y = height < 0 ? startY + height : startY
            const w = Math.abs(width)
            const h = Math.abs(height)

            selectionGraphics.beginFill(Config.COLORS.SELECTION, 0.2);
            selectionGraphics.lineStyle(1, Config.COLORS.SELECTION, 0.8);
            selectionGraphics.drawRect(x, y, w, h);
            selectionGraphics.endFill();
          }

          // 4. Update HUD Elements
          updateContextPopup();

          // 5. Pixi Draw
          app.renderer.render(app.stage);
        }

        // --- DOM HUD Logic ---
        function updateContextPopup() {
          const popup = document.getElementById('context-popup-bar');
          if (!popup) return;

          if (state.selection.active.size === 0) {
            popup.classList.add('hidden');
            return;
          }

          // Calculate bounds of selection on screen
          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const img of state.selection.active) {
             const x1 = img.x * state.camera.scale + state.camera.offsetX;
             const y1 = img.y * state.camera.scale + state.camera.offsetY;
             const w = img.width * img.scale * state.camera.scale;
             const h = img.height * img.scale * state.camera.scale;
             
             minX = Math.min(minX, x1);
             minY = Math.min(minY, y1);
             maxX = Math.max(maxX, x1 + w);
             maxY = Math.max(maxY, y1 + h);
          }

          const centerX = (minX + maxX) / 2;
          const topY = minY;
          
          // Clamp logic
          const pW = popup.offsetWidth, pH = popup.offsetHeight;
          const pad = 12;
          let left = Math.max(pW/2 + pad, Math.min(window.innerWidth - pW/2 - pad, centerX));
          let top = Math.max(pad, Math.min(window.innerHeight - pH - pad, topY - pH - 10));

          popup.style.left = `${left}px`;
          popup.style.top = `${top}px`;
          popup.classList.remove('hidden');
        }

        // --- Actions ---
        function addImage(filename) {
          fetch(`${Config.BASE_URL}/file/${encodeURI(filename)}`)
            .then(res => res.json())
            .then(metadata => {
              const img = new DeepZoomImage(0, 0, { filename, ...metadata }, requestRender);
              state.scene.images.push(img);
              worldContainer.addChild(img.container);
              requestRender();
            })
            .catch(e => console.error(e));
        }

        function layoutGrid() {
          LayoutEngine.arrangeGrid(state.scene.images);
          fitAll();
        }

        function fitAll() {
          const newCam = LayoutEngine.calculateFit(
            state.scene.images, app.screen.width, app.screen.height
          );
          if (newCam) {
            Object.assign(state.camera, newCam);
            requestRender();
          }
        }

        // --- Lifecycle ---
        onMounted(() => {
          app = new PIXI.Application({
            resizeTo: document.getElementById('app'),
            backgroundColor: 0x000000,
            antialias: true,
            autoStart: false
          });
          document.getElementById('app').appendChild(app.view);
          
          // Layers
          app.stage.addChild(worldContainer);
          app.stage.addChild(selectionGraphics); // Draw UI on top of World

          // Initialize Input Controller
          inputController = new InputController(app.view, state, requestRender);

          // Keyboard Shortcuts
          window.addEventListener('keydown', e => {
            if (e.code === 'KeyF') fitAll();
            if (e.code === 'KeyG') layoutGrid();
          });
          
          // Watchers for Selection State Visuals
          watch(() => Array.from(state.selection.active), () => {
             // Update "Selected" property on objects for render loop
             state.scene.images.forEach(img => {
                const wasSelected = img.selected;
                img.selected = state.selection.active.has(img);
                // Z-Index Hack: Bring selected to front of Pixi Container
                if (img.selected && !wasSelected) {
                  worldContainer.removeChild(img.container);
                  worldContainer.addChild(img.container);
                }
             });
             requestRender();
          });

          // Bootstrap Scene
          addImage('002_IDv3__aa855_s05_c0.tif');
          addImage('002_IDv3__aa855_s05_c1.tif');
          addImage('002_IDv3__aa855_s05_c2.tif');
          addImage('002_IDv3__aa855_s05_c3.tif');
          setTimeout(layoutGrid, 2000);
        });

        // Expose to Template
        return {
          ...toRefs(state),
          layoutGrid,
          fitAll
        };
      }
    }).mount('#app');
  </script>
</body>
</html>