<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pan/Zoom PixiJS</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #2c2c34;
    }
    #app {
      width: 100%;
      height: 100%;
      touch-action: none;
      position: relative;
    }
    /* Pixi canvas will be appended here, we ensure it fits */
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    /* ViewportHUD - overlay that floats above canvas */
    viewport-hud {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      display: block;
      z-index: 10;
    }

    viewport-hud > * {
      pointer-events: auto;
    }

    .hud-top-left {
      position: absolute;
      top: 12px;
      left: 12px;
    }

    .hud-bottom-right {
      position: absolute;
      bottom: 12px;
      right: 12px;
    }

    .hud-label {
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
    }

    .hud-btn {
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      border: none;
      padding: 6px 12px;
      border-radius: 4px;
      font-family: sans-serif;
      font-size: 12px;
      cursor: pointer;
      margin-left: 1ch;
    }

    .hud-btn:hover {
      background: rgba(0, 0, 0, 0.8);
    }
  </style>
</head>
<body>
  <div id="app">
    <viewport-hud>
      <div class="hud-top-left">
        <span id="zoom-label" class="hud-label">100%</span>
      </div>
      <div class="hud-bottom-right">
        <button id="grid-btn" class="hud-btn">Grid (G)</button>
        <button id="fit-btn" class="hud-btn">Fit All (F)</button>
      </div>
    </viewport-hud>
  </div>

  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>

  <script>
    const { createApp, onMounted, reactive } = Vue;

    class DraggableImage {
      constructor(x, y, width, height, metadata, tileSize = 256, maxZoomLevel = 4) {
        // State
        this.x = x;
        this.y = y;
        this.scale = 1;
        this.width = width;
        this.height = height;
        this.metadata = metadata;
        this.tileSize = tileSize;
        this.maxZoomLevel = maxZoomLevel;

        this.isDragging = false;
        this.dragLastX = 0;
        this.dragLastY = 0;

        // Cache
        this.tiles = new Map(); // key -> { texture, sprite, loading }
        this.visibleTiles = [];

        // Pixi Containers
        this.container = new PIXI.Container();
        
        // Layers: Background -> Tiles -> Overlay/Border
        this.bgGraphics = new PIXI.Graphics();
        this.tileContainer = new PIXI.Container();
        this.overlayGraphics = new PIXI.Graphics();
        
        this.container.addChild(this.bgGraphics);
        this.container.addChild(this.tileContainer);
        this.container.addChild(this.overlayGraphics);

        // Add a text label using Pixi
        this.textLabel = new PIXI.Text('', {
          fontFamily: 'monospace',
          fontSize: 14,
          fill: 0xaaaaaa,
        });
        this.overlayGraphics.addChild(this.textLabel);
      }

      containsPoint(px, py) {
        // Simple AABB check
        return px >= this.x && px <= this.x + this.width * this.scale &&
               py >= this.y && py <= this.y + this.height * this.scale;
      }

      computeVisibleTiles(app, state) {
        const worldScale = state.scale * this.scale;
        
        // LOD Calculation
        let level = Math.floor(Math.log2(1 / worldScale));
        level = Math.min(Math.max(level, 0), this.maxZoomLevel);
        const effectiveTileSize = this.tileSize * Math.pow(2, level);

        // Viewport culling (in Image Space)
        // 1. Get visible world bounds
        const viewportX = -state.offsetX / state.scale;
        const viewportY = -state.offsetY / state.scale;
        const viewportW = app.screen.width / state.scale;
        const viewportH = app.screen.height / state.scale;

        // 2. Convert to Local Image Space
        const ix0 = (viewportX - this.x) / this.scale;
        const iy0 = (viewportY - this.y) / this.scale;
        const ix1 = (viewportX + viewportW - this.x) / this.scale;
        const iy1 = (viewportY + viewportH - this.y) / this.scale;

        // 3. Clamp
        const cx0 = Math.max(0, ix0);
        const cy0 = Math.max(0, iy0);
        const cx1 = Math.min(this.width, ix1);
        const cy1 = Math.min(this.height, iy1);

        // 4. Calculate Indices
        const tx0 = Math.floor(cx0 / effectiveTileSize);
        const ty0 = Math.floor(cy0 / effectiveTileSize);
        const tx1 = Math.floor(cx1 / effectiveTileSize);
        const ty1 = Math.floor(cy1 / effectiveTileSize);

        const newVisibleKeys = new Set();

        for (let ty = ty0; ty <= ty1; ty++) {
          for (let tx = tx0; tx <= tx1; tx++) {
            const tz = 0;
            const tileX0 = tx * effectiveTileSize;
            const tileY0 = ty * effectiveTileSize;
            
            // Calculate dimensions based on LOD
            const tileWidth = Math.round(Math.min(effectiveTileSize, this.width - tileX0) / Math.pow(2, level));
            const tileHeight = Math.round(Math.min(effectiveTileSize, this.height - tileY0) / Math.pow(2, level));

            if (tileWidth <= 0 || tileHeight <= 0) continue;

            const tile = { tz, ty, tx, level, effectiveTileSize, tileWidth, tileHeight };
            const key = `L${level}_Z${tz}_${ty}_${tx}`;
            
            newVisibleKeys.add(key);
            this.syncTileSprite(tile, key);
          }
        }

        // Cleanup: Remove sprites that are no longer visible
        for (const [key, data] of this.tiles.entries()) {
          if (!newVisibleKeys.has(key) && data.sprite) {
             data.sprite.visible = false;
          }
        }
      }

      syncTileSprite(tile, key) {
        let cached = this.tiles.get(key);

        if (!cached) {
          // Initialize cache entry and fetch
          this.tiles.set(key, { loading: true, sprite: null, texture: null });
          this.fetchTile(tile, key);
          return;
        }

        if (cached.texture && !cached.sprite) {
           // Create sprite if we have texture but no sprite yet
           const sprite = new PIXI.Sprite(cached.texture);
           this.tileContainer.addChild(sprite);
           cached.sprite = sprite;
        }

        if (cached.sprite) {
           // Position and scale sprite
           cached.sprite.visible = true;
           // The sprite position in local image space (unscaled by this.scale, but scaled by Tile Size)
           cached.sprite.x = tile.tx * tile.effectiveTileSize;
           cached.sprite.y = tile.ty * tile.effectiveTileSize;
           
           // The texture itself is small (e.g. 256px), but it represents a large area (effectiveTileSize)
           // We scale the sprite up to fill that area
           const scaleFactor = Math.pow(2, tile.level);
           cached.sprite.width = tile.tileWidth * scaleFactor;
           cached.sprite.height = tile.tileHeight * scaleFactor;
        }
      }

      uint16ToTexture(uint16Data, width, height) {
        // Create a temporary canvas to generate the texture
        // Note: For high performance apps, use PIXI.BufferResource directly, 
        // but keeping canvas approach for simplicity and compatibility with previous logic.
        const bufferCanvas = document.createElement('canvas');
        bufferCanvas.width = width;
        bufferCanvas.height = height;
        const ctx = bufferCanvas.getContext('2d');
        const imageData = ctx.createImageData(width, height);
        const rgba = imageData.data;

        let min = 0, max = 4000;
        const range = max - min || 1;

        for (let i = 0; i < uint16Data.length; i++) {
          const val = Math.floor(((uint16Data[i] - min) / range) * 255);
          const idx = i * 4;
          rgba[idx] = val;
          rgba[idx + 1] = val;
          rgba[idx + 2] = val;
          rgba[idx + 3] = 255;
        }

        ctx.putImageData(imageData, 0, 0);
        return PIXI.Texture.from(bufferCanvas);
      }

      fetchTile(tile, key) {
        const BASE_URL = 'http://127.0.0.1:8000';
        const { filename } = this.metadata;

        fetch(BASE_URL + '/tile/' + encodeURI(filename) + '/' + key)
          .then(res => res.arrayBuffer())
          .then(buffer => {
            const uint16Data = new Uint16Array(buffer);
            
            // Convert to Pixi Texture
            const texture = this.uint16ToTexture(uint16Data, tile.tileWidth, tile.tileHeight);
            
            // Update cache
            const cached = this.tiles.get(key);
            if(cached) {
                cached.texture = texture;
                cached.loading = false;

                // Instead of linearly interpolating, keep 'pixelized' when zoomed in
                cached.texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST

                // Trigger an immediate sync to make it appear
                this.syncTileSprite(tile, key);
            }
          })
          .catch(err => {
            console.error('Failed to fetch tile', key, err);
            this.tiles.delete(key);
            
            // fallback for demo purposes if backend isn't running:
            // generateDummyTile(tile, key); 
          });
      }

      updateVisuals(app, state) {
        // 1. Update Container Transform
        this.container.x = this.x;
        this.container.y = this.y;
        this.container.scale.set(this.scale);

        // 2. Draw Background & Border (using PIXI.Graphics)
        const g = this.bgGraphics;
        g.clear();
        g.beginFill(0x646496, 0.3);
        g.drawRect(0, 0, this.width, this.height);
        g.endFill();

        const o = this.overlayGraphics;
        o.clear();
        // Selection/Border
        o.lineStyle(2 / (state.scale * this.scale), 0x4a9eff, 1);
        o.drawRect(0, 0, this.width, this.height);

        // Text Label
        this.textLabel.text = `${(this.scale * 100).toFixed(0)}%`;
        this.textLabel.x = 5 / this.scale;
        this.textLabel.y = 20 / this.scale;
        // Keep text size consistent relative to screen or relative to image?
        // Original code: constant size relative to image transform. 
        this.textLabel.scale.set(1 / this.scale); 

        // 3. Compute Tiles
        this.computeVisibleTiles(app, state);
      }
    }

    createApp({
      setup() {
        const state = reactive({
          offsetX: 0,
          offsetY: 0,
          scale: 1,
          isDragging: false,
          lastX: 0,
          lastY: 0,
          pointers: {},
          pinchStartDistance: 0,
          pinchStartScale: 1,
          draggableImages: [],
          activeDraggableImage: null
        });

        // Pixi Application
        let app;
        const worldContainer = new PIXI.Container();

        function getPointerDistance(p1, p2) {
          return Math.hypot(p2.x - p1.x, p2.y - p1.y);
        }

        function addImage(filename) {
          const BASE_URL = 'http://127.0.0.1:8000';
          
          fetch(BASE_URL + '/file/' + encodeURI(filename))
            .then(res => res.json())
            .then(metadata => {
              const img = new DraggableImage(
                0, 0, metadata.shape[1], metadata.shape[0],
                { filename, ...metadata }
              );
              
              state.draggableImages.push(img);
              worldContainer.addChild(img.container);
            })
            .catch(err => console.warn("Backend not reachable. Ensure python server is running."));
        }

        // Setup Scene
        function setupScene() {
          // Add 36 images for testing
          for (let i = 0; i < 9; i++) {
             // Mock metadata if backend is down, usually logic flows through fetch
             // But here we just trigger the addImage logic
             addImage('002_IDv3__aa855_s05_c1.tif');
          }
          
          // Wait a moment for async adds then arrange (dirty hack for demo)
          setTimeout(arrangeInGrid, 2000);
        }

        function zoomToFitAllImages() {
          if (state.draggableImages.length === 0) return;

          let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
          for (const img of state.draggableImages) {
            minX = Math.min(minX, img.x);
            minY = Math.min(minY, img.y);
            maxX = Math.max(maxX, img.x + img.width * img.scale);
            maxY = Math.max(maxY, img.y + img.height * img.scale);
          }

          if (minX === Infinity) return;

          const boundsWidth = maxX - minX;
          const boundsHeight = maxY - minY;
          const padding = 40;

          const scaleX = (app.screen.width - padding * 2) / boundsWidth;
          const scaleY = (app.screen.height - padding * 2) / boundsHeight;
          state.scale = Math.min(scaleX, scaleY);

          const centerX = (minX + maxX) / 2;
          const centerY = (minY + maxY) / 2;
          
          // Center in screen
          state.offsetX = app.screen.width / 2 - centerX * state.scale;
          state.offsetY = app.screen.height / 2 - centerY * state.scale;
        }

        function arrangeInGrid() {
          if (state.draggableImages.length === 0) return;

          const padding = 50;
          const images = state.draggableImages;
          const cols = Math.ceil(Math.sqrt(images.length));
          const colWidths = [];
          const rowHeights = [];

          // 1. Measure
          for (let i = 0; i < images.length; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const img = images[i];
            const w = img.width * img.scale;
            const h = img.height * img.scale;

            colWidths[col] = Math.max(colWidths[col] || 0, w);
            rowHeights[row] = Math.max(rowHeights[row] || 0, h);
          }

          // 2. Position
          for (let i = 0; i < images.length; i++) {
            const col = i % cols;
            const row = Math.floor(i / cols);
            const img = images[i];

            let x = 0;
            for (let c = 0; c < col; c++) x += colWidths[c] + padding;

            let y = 0;
            for (let r = 0; r < row; r++) y += rowHeights[r] + padding;

            img.x = x;
            img.y = y;
          }

          zoomToFitAllImages();
        }

        function screenToWorld(screenX, screenY) {
           return {
             wx: (screenX - state.offsetX) / state.scale,
             wy: (screenY - state.offsetY) / state.scale
           };
        }

        onMounted(() => {
          // Initialize Pixi
          app = new PIXI.Application({
            resizeTo: document.getElementById('app'),
            backgroundColor: 0x2c2c34,
            antialias: true,
            resolution: window.devicePixelRatio || 1,
            autoDensity: true
          });
          document.getElementById('app').appendChild(app.view);
          
          app.stage.addChild(worldContainer);

          // Interaction Handlers (Mouse/Touch)
          const view = app.view;

          view.addEventListener('contextmenu', e => e.preventDefault());

          view.addEventListener('mousedown', e => {
            const { wx, wy } = screenToWorld(e.clientX, e.clientY);

            // Middle mouse pan
            if (e.button == 1 || (e.button == 0 && e.altKey)) {
              state.isDragging = true;
              state.lastX = e.clientX;
              state.lastY = e.clientY;
              return;
            }

            // Hit test images
            if (e.button == 0) {
              // Iterate in reverse to hit top-most first
              for (let i = state.draggableImages.length - 1; i >= 0; i--) {
                const img = state.draggableImages[i];
                if (img.containsPoint(wx, wy)) {
                  state.activeDraggableImage = img;
                  img.isDragging = true;
                  img.dragLastX = e.clientX;
                  img.dragLastY = e.clientY;
                  
                  // Move to top of display stack
                  worldContainer.removeChild(img.container);
                  worldContainer.addChild(img.container);
                  break;
                }
              }
            }
          });

          window.addEventListener('mousemove', e => {
            // Pan World
            if (state.isDragging) {
              const dx = e.clientX - state.lastX;
              const dy = e.clientY - state.lastY;
              state.offsetX += dx;
              state.offsetY += dy;
              state.lastX = e.clientX;
              state.lastY = e.clientY;
            }

            // Drag Image
            if (state.activeDraggableImage) {
              const img = state.activeDraggableImage;
              const dx = e.clientX - img.dragLastX;
              const dy = e.clientY - img.dragLastY;

              img.x += dx / state.scale;
              img.y += dy / state.scale;

              img.dragLastX = e.clientX;
              img.dragLastY = e.clientY;
            }
          });

          window.addEventListener('mouseup', () => {
            state.isDragging = false;
            if (state.activeDraggableImage) {
              state.activeDraggableImage.isDragging = false;
              state.activeDraggableImage = null;
            }
          });

          // Zoom
          view.addEventListener('wheel', e => {
            e.preventDefault();
            
            if (e.ctrlKey) {
              const zoomIntensity = 0.002; // Adjusted for Pixi sensitivity
              const delta = -e.deltaY;
              const newScale = Math.max(0.01, state.scale * (1 + delta * zoomIntensity));

              const rect = view.getBoundingClientRect();
              const mx = e.clientX - rect.left;
              const my = e.clientY - rect.top;

              // Zoom towards mouse pointer logic
              state.offsetX -= (mx - state.offsetX) * (newScale / state.scale - 1);
              state.offsetY -= (my - state.offsetY) * (newScale / state.scale - 1);

              state.scale = newScale;
            } else {
              // Pan with wheel
              state.offsetX -= e.deltaX;
              state.offsetY -= e.deltaY;
            }
          }, { passive: false });

          // Keyboard
          window.addEventListener('keydown', e => {
            if (e.code === 'KeyF') zoomToFitAllImages();
            if (e.code === 'KeyG') arrangeInGrid();
          });
          
          document.getElementById('fit-btn').addEventListener('click', zoomToFitAllImages);
          document.getElementById('grid-btn').addEventListener('click', arrangeInGrid);

          // Setup Data
          setupScene();

          // Ticker: Sync State -> Pixi Scene
          app.ticker.add(() => {
             // 1. Sync World Container
             worldContainer.x = state.offsetX;
             worldContainer.y = state.offsetY;
             worldContainer.scale.set(state.scale);

             // 2. Sync Images
             state.draggableImages.forEach(img => img.updateVisuals(app, state));

             // 3. Update HUD
             const zoomLabel = document.getElementById('zoom-label');
             if (zoomLabel) zoomLabel.textContent = `${(state.scale * 100).toFixed(0)}%`;
          });
        });

        return {};
      }
    }).mount('#app');
  </script>
</body>
</html>